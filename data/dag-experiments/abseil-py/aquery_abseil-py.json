{
  "artifacts": [{
    "id": 1,
    "pathFragmentId": 1
  }, {
    "id": 2,
    "pathFragmentId": 8
  }, {
    "id": 3,
    "pathFragmentId": 9
  }, {
    "id": 4,
    "pathFragmentId": 11
  }, {
    "id": 5,
    "pathFragmentId": 15
  }, {
    "id": 6,
    "pathFragmentId": 16
  }, {
    "id": 7,
    "pathFragmentId": 17
  }, {
    "id": 8,
    "pathFragmentId": 19
  }, {
    "id": 9,
    "pathFragmentId": 20
  }, {
    "id": 10,
    "pathFragmentId": 21
  }, {
    "id": 11,
    "pathFragmentId": 22
  }, {
    "id": 12,
    "pathFragmentId": 23
  }, {
    "id": 13,
    "pathFragmentId": 24
  }, {
    "id": 14,
    "pathFragmentId": 25
  }, {
    "id": 15,
    "pathFragmentId": 26
  }, {
    "id": 16,
    "pathFragmentId": 27
  }, {
    "id": 17,
    "pathFragmentId": 29
  }, {
    "id": 18,
    "pathFragmentId": 30
  }, {
    "id": 19,
    "pathFragmentId": 31
  }, {
    "id": 20,
    "pathFragmentId": 32
  }, {
    "id": 21,
    "pathFragmentId": 33
  }, {
    "id": 22,
    "pathFragmentId": 38
  }, {
    "id": 23,
    "pathFragmentId": 41
  }, {
    "id": 24,
    "pathFragmentId": 42
  }, {
    "id": 25,
    "pathFragmentId": 48
  }, {
    "id": 26,
    "pathFragmentId": 49
  }, {
    "id": 27,
    "pathFragmentId": 52
  }, {
    "id": 28,
    "pathFragmentId": 53
  }, {
    "id": 29,
    "pathFragmentId": 55
  }, {
    "id": 30,
    "pathFragmentId": 57
  }, {
    "id": 31,
    "pathFragmentId": 58
  }, {
    "id": 32,
    "pathFragmentId": 59
  }, {
    "id": 33,
    "pathFragmentId": 60
  }, {
    "id": 34,
    "pathFragmentId": 62
  }, {
    "id": 35,
    "pathFragmentId": 63
  }, {
    "id": 36,
    "pathFragmentId": 69
  }, {
    "id": 37,
    "pathFragmentId": 70
  }, {
    "id": 38,
    "pathFragmentId": 71
  }, {
    "id": 39,
    "pathFragmentId": 72
  }, {
    "id": 40,
    "pathFragmentId": 74
  }, {
    "id": 41,
    "pathFragmentId": 75
  }, {
    "id": 42,
    "pathFragmentId": 76
  }, {
    "id": 43,
    "pathFragmentId": 77
  }, {
    "id": 44,
    "pathFragmentId": 78
  }, {
    "id": 45,
    "pathFragmentId": 79
  }, {
    "id": 46,
    "pathFragmentId": 80
  }, {
    "id": 47,
    "pathFragmentId": 81
  }, {
    "id": 48,
    "pathFragmentId": 83
  }, {
    "id": 49,
    "pathFragmentId": 84
  }, {
    "id": 50,
    "pathFragmentId": 85
  }, {
    "id": 51,
    "pathFragmentId": 86
  }, {
    "id": 52,
    "pathFragmentId": 87
  }, {
    "id": 53,
    "pathFragmentId": 88
  }, {
    "id": 54,
    "pathFragmentId": 89
  }, {
    "id": 55,
    "pathFragmentId": 90
  }, {
    "id": 56,
    "pathFragmentId": 91
  }, {
    "id": 57,
    "pathFragmentId": 92
  }, {
    "id": 58,
    "pathFragmentId": 96
  }, {
    "id": 59,
    "pathFragmentId": 97
  }, {
    "id": 60,
    "pathFragmentId": 99
  }, {
    "id": 61,
    "pathFragmentId": 100
  }, {
    "id": 62,
    "pathFragmentId": 102
  }, {
    "id": 63,
    "pathFragmentId": 104
  }, {
    "id": 64,
    "pathFragmentId": 105
  }, {
    "id": 65,
    "pathFragmentId": 106
  }, {
    "id": 66,
    "pathFragmentId": 107
  }, {
    "id": 67,
    "pathFragmentId": 110
  }, {
    "id": 68,
    "pathFragmentId": 111
  }, {
    "id": 69,
    "pathFragmentId": 112
  }, {
    "id": 70,
    "pathFragmentId": 113
  }, {
    "id": 71,
    "pathFragmentId": 115
  }, {
    "id": 72,
    "pathFragmentId": 116
  }, {
    "id": 73,
    "pathFragmentId": 117
  }, {
    "id": 74,
    "pathFragmentId": 118
  }, {
    "id": 75,
    "pathFragmentId": 119
  }, {
    "id": 76,
    "pathFragmentId": 120
  }, {
    "id": 77,
    "pathFragmentId": 121
  }, {
    "id": 78,
    "pathFragmentId": 123
  }, {
    "id": 79,
    "pathFragmentId": 124
  }, {
    "id": 80,
    "pathFragmentId": 125
  }, {
    "id": 81,
    "pathFragmentId": 126
  }, {
    "id": 82,
    "pathFragmentId": 127
  }, {
    "id": 83,
    "pathFragmentId": 128
  }, {
    "id": 84,
    "pathFragmentId": 129
  }, {
    "id": 85,
    "pathFragmentId": 131
  }, {
    "id": 86,
    "pathFragmentId": 132
  }, {
    "id": 87,
    "pathFragmentId": 133
  }, {
    "id": 88,
    "pathFragmentId": 134
  }, {
    "id": 89,
    "pathFragmentId": 136
  }, {
    "id": 90,
    "pathFragmentId": 137
  }, {
    "id": 91,
    "pathFragmentId": 138
  }, {
    "id": 92,
    "pathFragmentId": 139
  }, {
    "id": 93,
    "pathFragmentId": 140
  }, {
    "id": 94,
    "pathFragmentId": 142
  }, {
    "id": 95,
    "pathFragmentId": 143
  }, {
    "id": 96,
    "pathFragmentId": 146
  }, {
    "id": 97,
    "pathFragmentId": 147
  }, {
    "id": 98,
    "pathFragmentId": 149
  }, {
    "id": 99,
    "pathFragmentId": 151
  }, {
    "id": 100,
    "pathFragmentId": 152
  }, {
    "id": 101,
    "pathFragmentId": 153
  }, {
    "id": 102,
    "pathFragmentId": 154
  }, {
    "id": 103,
    "pathFragmentId": 158
  }, {
    "id": 104,
    "pathFragmentId": 159
  }, {
    "id": 105,
    "pathFragmentId": 160
  }, {
    "id": 106,
    "pathFragmentId": 161
  }, {
    "id": 107,
    "pathFragmentId": 163
  }, {
    "id": 108,
    "pathFragmentId": 164
  }, {
    "id": 109,
    "pathFragmentId": 165
  }, {
    "id": 110,
    "pathFragmentId": 166
  }, {
    "id": 111,
    "pathFragmentId": 167
  }, {
    "id": 112,
    "pathFragmentId": 168
  }, {
    "id": 113,
    "pathFragmentId": 169
  }, {
    "id": 114,
    "pathFragmentId": 171
  }, {
    "id": 115,
    "pathFragmentId": 172
  }, {
    "id": 116,
    "pathFragmentId": 173
  }, {
    "id": 117,
    "pathFragmentId": 174
  }, {
    "id": 118,
    "pathFragmentId": 175
  }, {
    "id": 119,
    "pathFragmentId": 176
  }, {
    "id": 120,
    "pathFragmentId": 177
  }, {
    "id": 121,
    "pathFragmentId": 178
  }, {
    "id": 122,
    "pathFragmentId": 180
  }, {
    "id": 123,
    "pathFragmentId": 181
  }, {
    "id": 124,
    "pathFragmentId": 182
  }, {
    "id": 125,
    "pathFragmentId": 183
  }, {
    "id": 126,
    "pathFragmentId": 185
  }, {
    "id": 127,
    "pathFragmentId": 186
  }, {
    "id": 128,
    "pathFragmentId": 187
  }, {
    "id": 129,
    "pathFragmentId": 188
  }, {
    "id": 130,
    "pathFragmentId": 189
  }, {
    "id": 131,
    "pathFragmentId": 191
  }, {
    "id": 132,
    "pathFragmentId": 192
  }, {
    "id": 133,
    "pathFragmentId": 193
  }, {
    "id": 134,
    "pathFragmentId": 194
  }, {
    "id": 135,
    "pathFragmentId": 196
  }, {
    "id": 136,
    "pathFragmentId": 197
  }, {
    "id": 137,
    "pathFragmentId": 198
  }, {
    "id": 138,
    "pathFragmentId": 199
  }, {
    "id": 139,
    "pathFragmentId": 200
  }, {
    "id": 140,
    "pathFragmentId": 202
  }, {
    "id": 141,
    "pathFragmentId": 203
  }, {
    "id": 142,
    "pathFragmentId": 204
  }, {
    "id": 143,
    "pathFragmentId": 205
  }, {
    "id": 144,
    "pathFragmentId": 207
  }, {
    "id": 145,
    "pathFragmentId": 208
  }, {
    "id": 146,
    "pathFragmentId": 209
  }, {
    "id": 147,
    "pathFragmentId": 210
  }, {
    "id": 148,
    "pathFragmentId": 211
  }, {
    "id": 149,
    "pathFragmentId": 212
  }, {
    "id": 150,
    "pathFragmentId": 213
  }, {
    "id": 151,
    "pathFragmentId": 215
  }, {
    "id": 152,
    "pathFragmentId": 216
  }, {
    "id": 153,
    "pathFragmentId": 217
  }, {
    "id": 154,
    "pathFragmentId": 218
  }, {
    "id": 155,
    "pathFragmentId": 219
  }, {
    "id": 156,
    "pathFragmentId": 221
  }, {
    "id": 157,
    "pathFragmentId": 222
  }, {
    "id": 158,
    "pathFragmentId": 223
  }, {
    "id": 159,
    "pathFragmentId": 224
  }, {
    "id": 160,
    "pathFragmentId": 226
  }, {
    "id": 161,
    "pathFragmentId": 227
  }, {
    "id": 162,
    "pathFragmentId": 228
  }, {
    "id": 163,
    "pathFragmentId": 229
  }, {
    "id": 164,
    "pathFragmentId": 230
  }, {
    "id": 165,
    "pathFragmentId": 232
  }, {
    "id": 166,
    "pathFragmentId": 233
  }, {
    "id": 167,
    "pathFragmentId": 234
  }, {
    "id": 168,
    "pathFragmentId": 235
  }, {
    "id": 169,
    "pathFragmentId": 237
  }, {
    "id": 170,
    "pathFragmentId": 238
  }, {
    "id": 171,
    "pathFragmentId": 239
  }, {
    "id": 172,
    "pathFragmentId": 240
  }, {
    "id": 173,
    "pathFragmentId": 241
  }, {
    "id": 174,
    "pathFragmentId": 242
  }, {
    "id": 175,
    "pathFragmentId": 243
  }, {
    "id": 176,
    "pathFragmentId": 246
  }, {
    "id": 177,
    "pathFragmentId": 247
  }, {
    "id": 178,
    "pathFragmentId": 249
  }, {
    "id": 179,
    "pathFragmentId": 250
  }, {
    "id": 180,
    "pathFragmentId": 252
  }, {
    "id": 181,
    "pathFragmentId": 253
  }, {
    "id": 182,
    "pathFragmentId": 255
  }, {
    "id": 183,
    "pathFragmentId": 256
  }, {
    "id": 184,
    "pathFragmentId": 258
  }, {
    "id": 185,
    "pathFragmentId": 259
  }, {
    "id": 186,
    "pathFragmentId": 261
  }, {
    "id": 187,
    "pathFragmentId": 262
  }, {
    "id": 188,
    "pathFragmentId": 264
  }, {
    "id": 189,
    "pathFragmentId": 265
  }, {
    "id": 190,
    "pathFragmentId": 267
  }, {
    "id": 191,
    "pathFragmentId": 268
  }, {
    "id": 192,
    "pathFragmentId": 270
  }, {
    "id": 193,
    "pathFragmentId": 271
  }, {
    "id": 194,
    "pathFragmentId": 273
  }, {
    "id": 195,
    "pathFragmentId": 274
  }, {
    "id": 196,
    "pathFragmentId": 276
  }, {
    "id": 197,
    "pathFragmentId": 277
  }, {
    "id": 198,
    "pathFragmentId": 279
  }, {
    "id": 199,
    "pathFragmentId": 280
  }, {
    "id": 200,
    "pathFragmentId": 282
  }, {
    "id": 201,
    "pathFragmentId": 283
  }, {
    "id": 202,
    "pathFragmentId": 285
  }, {
    "id": 203,
    "pathFragmentId": 286
  }, {
    "id": 204,
    "pathFragmentId": 288
  }, {
    "id": 205,
    "pathFragmentId": 289
  }, {
    "id": 206,
    "pathFragmentId": 291
  }, {
    "id": 207,
    "pathFragmentId": 292
  }, {
    "id": 208,
    "pathFragmentId": 294
  }, {
    "id": 209,
    "pathFragmentId": 295
  }, {
    "id": 210,
    "pathFragmentId": 297
  }, {
    "id": 211,
    "pathFragmentId": 298
  }, {
    "id": 212,
    "pathFragmentId": 300
  }, {
    "id": 213,
    "pathFragmentId": 301
  }, {
    "id": 214,
    "pathFragmentId": 303
  }, {
    "id": 215,
    "pathFragmentId": 304
  }, {
    "id": 216,
    "pathFragmentId": 306
  }, {
    "id": 217,
    "pathFragmentId": 307
  }, {
    "id": 218,
    "pathFragmentId": 309
  }, {
    "id": 219,
    "pathFragmentId": 310
  }, {
    "id": 220,
    "pathFragmentId": 312
  }, {
    "id": 221,
    "pathFragmentId": 313
  }, {
    "id": 222,
    "pathFragmentId": 315
  }, {
    "id": 223,
    "pathFragmentId": 316
  }, {
    "id": 224,
    "pathFragmentId": 318
  }, {
    "id": 225,
    "pathFragmentId": 319
  }, {
    "id": 226,
    "pathFragmentId": 321
  }, {
    "id": 227,
    "pathFragmentId": 322
  }, {
    "id": 228,
    "pathFragmentId": 324
  }, {
    "id": 229,
    "pathFragmentId": 325
  }, {
    "id": 230,
    "pathFragmentId": 327
  }, {
    "id": 231,
    "pathFragmentId": 328
  }, {
    "id": 232,
    "pathFragmentId": 330
  }, {
    "id": 233,
    "pathFragmentId": 331
  }, {
    "id": 234,
    "pathFragmentId": 333
  }, {
    "id": 235,
    "pathFragmentId": 334
  }, {
    "id": 236,
    "pathFragmentId": 336
  }, {
    "id": 237,
    "pathFragmentId": 337
  }, {
    "id": 238,
    "pathFragmentId": 339
  }, {
    "id": 239,
    "pathFragmentId": 340
  }, {
    "id": 240,
    "pathFragmentId": 342
  }, {
    "id": 241,
    "pathFragmentId": 343
  }, {
    "id": 242,
    "pathFragmentId": 345
  }, {
    "id": 243,
    "pathFragmentId": 346
  }, {
    "id": 244,
    "pathFragmentId": 348
  }, {
    "id": 245,
    "pathFragmentId": 349
  }, {
    "id": 246,
    "pathFragmentId": 351
  }, {
    "id": 247,
    "pathFragmentId": 352
  }, {
    "id": 248,
    "pathFragmentId": 354
  }, {
    "id": 249,
    "pathFragmentId": 355
  }, {
    "id": 250,
    "pathFragmentId": 357
  }, {
    "id": 251,
    "pathFragmentId": 358
  }, {
    "id": 252,
    "pathFragmentId": 360
  }, {
    "id": 253,
    "pathFragmentId": 361
  }, {
    "id": 254,
    "pathFragmentId": 363
  }, {
    "id": 255,
    "pathFragmentId": 364
  }, {
    "id": 256,
    "pathFragmentId": 366
  }, {
    "id": 257,
    "pathFragmentId": 367
  }, {
    "id": 258,
    "pathFragmentId": 369
  }, {
    "id": 259,
    "pathFragmentId": 370
  }, {
    "id": 260,
    "pathFragmentId": 372
  }, {
    "id": 261,
    "pathFragmentId": 373
  }, {
    "id": 262,
    "pathFragmentId": 375
  }, {
    "id": 263,
    "pathFragmentId": 376
  }, {
    "id": 264,
    "pathFragmentId": 378
  }, {
    "id": 265,
    "pathFragmentId": 379
  }, {
    "id": 266,
    "pathFragmentId": 381
  }, {
    "id": 267,
    "pathFragmentId": 382
  }, {
    "id": 268,
    "pathFragmentId": 384
  }, {
    "id": 269,
    "pathFragmentId": 385
  }, {
    "id": 270,
    "pathFragmentId": 387
  }, {
    "id": 271,
    "pathFragmentId": 388
  }, {
    "id": 272,
    "pathFragmentId": 390
  }, {
    "id": 273,
    "pathFragmentId": 391
  }, {
    "id": 274,
    "pathFragmentId": 393
  }, {
    "id": 275,
    "pathFragmentId": 394
  }, {
    "id": 276,
    "pathFragmentId": 395
  }, {
    "id": 277,
    "pathFragmentId": 396
  }, {
    "id": 278,
    "pathFragmentId": 398
  }, {
    "id": 279,
    "pathFragmentId": 399
  }, {
    "id": 280,
    "pathFragmentId": 400
  }, {
    "id": 281,
    "pathFragmentId": 401
  }, {
    "id": 282,
    "pathFragmentId": 402
  }, {
    "id": 283,
    "pathFragmentId": 404
  }, {
    "id": 284,
    "pathFragmentId": 405
  }, {
    "id": 285,
    "pathFragmentId": 406
  }, {
    "id": 286,
    "pathFragmentId": 407
  }, {
    "id": 287,
    "pathFragmentId": 409
  }, {
    "id": 288,
    "pathFragmentId": 410
  }, {
    "id": 289,
    "pathFragmentId": 411
  }, {
    "id": 290,
    "pathFragmentId": 412
  }, {
    "id": 291,
    "pathFragmentId": 413
  }, {
    "id": 292,
    "pathFragmentId": 415
  }, {
    "id": 293,
    "pathFragmentId": 416
  }, {
    "id": 294,
    "pathFragmentId": 417
  }, {
    "id": 295,
    "pathFragmentId": 418
  }, {
    "id": 296,
    "pathFragmentId": 420
  }, {
    "id": 297,
    "pathFragmentId": 421
  }, {
    "id": 298,
    "pathFragmentId": 422
  }, {
    "id": 299,
    "pathFragmentId": 423
  }, {
    "id": 300,
    "pathFragmentId": 424
  }, {
    "id": 301,
    "pathFragmentId": 426
  }, {
    "id": 302,
    "pathFragmentId": 427
  }, {
    "id": 303,
    "pathFragmentId": 428
  }, {
    "id": 304,
    "pathFragmentId": 430
  }, {
    "id": 305,
    "pathFragmentId": 431
  }, {
    "id": 306,
    "pathFragmentId": 432
  }, {
    "id": 307,
    "pathFragmentId": 433
  }, {
    "id": 308,
    "pathFragmentId": 434
  }, {
    "id": 309,
    "pathFragmentId": 435
  }, {
    "id": 310,
    "pathFragmentId": 437
  }, {
    "id": 311,
    "pathFragmentId": 438
  }, {
    "id": 312,
    "pathFragmentId": 439
  }, {
    "id": 313,
    "pathFragmentId": 440
  }, {
    "id": 314,
    "pathFragmentId": 441
  }, {
    "id": 315,
    "pathFragmentId": 443
  }, {
    "id": 316,
    "pathFragmentId": 444
  }, {
    "id": 317,
    "pathFragmentId": 445
  }, {
    "id": 318,
    "pathFragmentId": 446
  }, {
    "id": 319,
    "pathFragmentId": 448
  }, {
    "id": 320,
    "pathFragmentId": 449
  }, {
    "id": 321,
    "pathFragmentId": 450
  }, {
    "id": 322,
    "pathFragmentId": 451
  }, {
    "id": 323,
    "pathFragmentId": 452
  }, {
    "id": 324,
    "pathFragmentId": 454
  }, {
    "id": 325,
    "pathFragmentId": 455
  }, {
    "id": 326,
    "pathFragmentId": 456
  }, {
    "id": 327,
    "pathFragmentId": 458
  }, {
    "id": 328,
    "pathFragmentId": 459
  }, {
    "id": 329,
    "pathFragmentId": 460
  }, {
    "id": 330,
    "pathFragmentId": 461
  }, {
    "id": 331,
    "pathFragmentId": 462
  }, {
    "id": 332,
    "pathFragmentId": 463
  }, {
    "id": 333,
    "pathFragmentId": 465
  }, {
    "id": 334,
    "pathFragmentId": 466
  }, {
    "id": 335,
    "pathFragmentId": 467
  }, {
    "id": 336,
    "pathFragmentId": 468
  }, {
    "id": 337,
    "pathFragmentId": 469
  }, {
    "id": 338,
    "pathFragmentId": 470
  }, {
    "id": 339,
    "pathFragmentId": 471
  }, {
    "id": 340,
    "pathFragmentId": 473
  }, {
    "id": 341,
    "pathFragmentId": 474
  }, {
    "id": 342,
    "pathFragmentId": 475
  }, {
    "id": 343,
    "pathFragmentId": 476
  }, {
    "id": 344,
    "pathFragmentId": 477
  }, {
    "id": 345,
    "pathFragmentId": 479
  }, {
    "id": 346,
    "pathFragmentId": 480
  }, {
    "id": 347,
    "pathFragmentId": 481
  }, {
    "id": 348,
    "pathFragmentId": 482
  }, {
    "id": 349,
    "pathFragmentId": 484
  }, {
    "id": 350,
    "pathFragmentId": 485
  }, {
    "id": 351,
    "pathFragmentId": 486
  }, {
    "id": 352,
    "pathFragmentId": 487
  }, {
    "id": 353,
    "pathFragmentId": 488
  }, {
    "id": 354,
    "pathFragmentId": 490
  }, {
    "id": 355,
    "pathFragmentId": 491
  }, {
    "id": 356,
    "pathFragmentId": 492
  }, {
    "id": 357,
    "pathFragmentId": 493
  }, {
    "id": 358,
    "pathFragmentId": 495
  }, {
    "id": 359,
    "pathFragmentId": 496
  }, {
    "id": 360,
    "pathFragmentId": 497
  }, {
    "id": 361,
    "pathFragmentId": 498
  }, {
    "id": 362,
    "pathFragmentId": 499
  }, {
    "id": 363,
    "pathFragmentId": 500
  }, {
    "id": 364,
    "pathFragmentId": 502
  }, {
    "id": 365,
    "pathFragmentId": 503
  }, {
    "id": 366,
    "pathFragmentId": 504
  }, {
    "id": 367,
    "pathFragmentId": 505
  }, {
    "id": 368,
    "pathFragmentId": 507
  }, {
    "id": 369,
    "pathFragmentId": 508
  }, {
    "id": 370,
    "pathFragmentId": 509
  }, {
    "id": 371,
    "pathFragmentId": 510
  }, {
    "id": 372,
    "pathFragmentId": 511
  }, {
    "id": 373,
    "pathFragmentId": 513
  }, {
    "id": 374,
    "pathFragmentId": 514
  }, {
    "id": 375,
    "pathFragmentId": 515
  }, {
    "id": 376,
    "pathFragmentId": 517
  }, {
    "id": 377,
    "pathFragmentId": 518
  }, {
    "id": 378,
    "pathFragmentId": 519
  }, {
    "id": 379,
    "pathFragmentId": 520
  }, {
    "id": 380,
    "pathFragmentId": 521
  }, {
    "id": 381,
    "pathFragmentId": 522
  }, {
    "id": 382,
    "pathFragmentId": 524
  }, {
    "id": 383,
    "pathFragmentId": 525
  }, {
    "id": 384,
    "pathFragmentId": 526
  }, {
    "id": 385,
    "pathFragmentId": 527
  }, {
    "id": 386,
    "pathFragmentId": 528
  }, {
    "id": 387,
    "pathFragmentId": 530
  }, {
    "id": 388,
    "pathFragmentId": 531
  }, {
    "id": 389,
    "pathFragmentId": 532
  }, {
    "id": 390,
    "pathFragmentId": 533
  }, {
    "id": 391,
    "pathFragmentId": 535
  }, {
    "id": 392,
    "pathFragmentId": 536
  }, {
    "id": 393,
    "pathFragmentId": 537
  }, {
    "id": 394,
    "pathFragmentId": 538
  }, {
    "id": 395,
    "pathFragmentId": 539
  }, {
    "id": 396,
    "pathFragmentId": 541
  }, {
    "id": 397,
    "pathFragmentId": 542
  }, {
    "id": 398,
    "pathFragmentId": 543
  }, {
    "id": 399,
    "pathFragmentId": 544
  }, {
    "id": 400,
    "pathFragmentId": 546
  }, {
    "id": 401,
    "pathFragmentId": 547
  }, {
    "id": 402,
    "pathFragmentId": 548
  }, {
    "id": 403,
    "pathFragmentId": 549
  }, {
    "id": 404,
    "pathFragmentId": 550
  }, {
    "id": 405,
    "pathFragmentId": 552
  }, {
    "id": 406,
    "pathFragmentId": 553
  }, {
    "id": 407,
    "pathFragmentId": 554
  }, {
    "id": 408,
    "pathFragmentId": 555
  }, {
    "id": 409,
    "pathFragmentId": 557
  }, {
    "id": 410,
    "pathFragmentId": 558
  }, {
    "id": 411,
    "pathFragmentId": 559
  }, {
    "id": 412,
    "pathFragmentId": 560
  }, {
    "id": 413,
    "pathFragmentId": 561
  }, {
    "id": 414,
    "pathFragmentId": 563
  }, {
    "id": 415,
    "pathFragmentId": 564
  }, {
    "id": 416,
    "pathFragmentId": 565
  }, {
    "id": 417,
    "pathFragmentId": 566
  }, {
    "id": 418,
    "pathFragmentId": 568
  }, {
    "id": 419,
    "pathFragmentId": 569
  }, {
    "id": 420,
    "pathFragmentId": 570
  }, {
    "id": 421,
    "pathFragmentId": 571
  }, {
    "id": 422,
    "pathFragmentId": 572
  }, {
    "id": 423,
    "pathFragmentId": 574
  }, {
    "id": 424,
    "pathFragmentId": 575
  }, {
    "id": 425,
    "pathFragmentId": 576
  }, {
    "id": 426,
    "pathFragmentId": 577
  }, {
    "id": 427,
    "pathFragmentId": 579
  }, {
    "id": 428,
    "pathFragmentId": 580
  }, {
    "id": 429,
    "pathFragmentId": 581
  }, {
    "id": 430,
    "pathFragmentId": 582
  }, {
    "id": 431,
    "pathFragmentId": 583
  }, {
    "id": 432,
    "pathFragmentId": 585
  }, {
    "id": 433,
    "pathFragmentId": 586
  }, {
    "id": 434,
    "pathFragmentId": 588
  }, {
    "id": 435,
    "pathFragmentId": 589
  }, {
    "id": 436,
    "pathFragmentId": 590
  }],
  "actions": [{
    "targetId": 1,
    "actionKey": "8dcfb595a62a304afa9e2a99fe82ad41c0e2bb78010c80d124d1893127c37899",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [1],
    "primaryOutputId": 1,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_fail_fast_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_fail_fast_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 1,
    "actionKey": "84f05c2fee22c638e034a70af77f3abcb3ed97804780667f5cd55faed26f9cb7",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [2],
    "primaryOutputId": 2,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 1,
    "actionKey": "ed0fd5bdf288615577c1ec0129c4001353292ca50c7c8c2b65aeba36c68d18b0",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [1],
    "outputIds": [3],
    "primaryOutputId": 3,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 1,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [2],
    "outputIds": [22],
    "primaryOutputId": 22,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 1,
    "actionKey": "1ab125e4f693d3e70cb8267871cf31d0bd75672814b7b60ff7232f4a64a2cf19",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [23],
    "primaryOutputId": 23,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_fail_fast_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_fail_fast_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 1,
    "actionKey": "a16d9262ea0e87bbe6d1bc4b6d770da9cea8d892e3ca5eb76e36ac0d77d77f37",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [18],
    "outputIds": [25],
    "primaryOutputId": 25,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 2,
    "actionKey": "43d5582ae5884f2de076cadd681be739eeac69e048262a112f6d846e9768c551",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [26],
    "primaryOutputId": 26,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_unicode_literals_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_unicode_literals_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 2,
    "actionKey": "97a9f243938766cf133ac2ed5d6c4cca9f2d6be40fc742bc61791fc93535e0f2",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [27],
    "primaryOutputId": 27,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 2,
    "actionKey": "8d59e2f3ef3ac6cac271eefe97edafbb4cebf87ccaf5baade5db3afb8b663466",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [20],
    "outputIds": [28],
    "primaryOutputId": 28,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 2,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [21],
    "outputIds": [30],
    "primaryOutputId": 30,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 2,
    "actionKey": "774324df12c9c32d9ca31c560b42bbdafcfcf5a9ce687e6adacaa3dd2551510a",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [31],
    "primaryOutputId": 31,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_unicode_literals_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_unicode_literals_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 2,
    "actionKey": "c15c0d93009ae203a3fe571ddc660e338663c51a7c5632fd401fc0f25cb4b6fa",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [25],
    "outputIds": [32],
    "primaryOutputId": 32,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 2,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [27],
    "outputIds": [35, 36],
    "primaryOutputId": 35,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 3,
    "actionKey": "5c8d1b1454c6d781fcfd1deea27186750d2a2a0ad6e71fd8a068673e1f2470bb",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [37],
    "primaryOutputId": 37,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/argparse_flags_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/argparse_flags_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 3,
    "actionKey": "1c14951476546e3fb0bbef917fee17bc881bed3ade7dec10420ceeb88de55615",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [38],
    "primaryOutputId": 38,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 3,
    "actionKey": "012bc82c36ed7123d3a949cb0bf1f33efc16dda423f336624c3e8f368c81113d",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [28],
    "outputIds": [39],
    "primaryOutputId": 39,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 3,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [29],
    "outputIds": [42],
    "primaryOutputId": 42,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 3,
    "actionKey": "dd6f3eb108f09f1d46df579ce37a983ce7d7d155d2501bbbe8382e8774cc2620",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [43],
    "primaryOutputId": 43,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/argparse_flags_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/argparse_flags_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 3,
    "actionKey": "f838e23c1c1db764463f74f49abb05a6c44dd32fa9416768a5e4b2c9928088fb",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [34],
    "outputIds": [44],
    "primaryOutputId": 44,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 4,
    "actionKey": "8216580ed71c01068bcebff85d4ac30716051e30e1ae49ae02a58f9f9ef6e892",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [45],
    "primaryOutputId": 45,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_randomization_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_randomization_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 4,
    "actionKey": "b172133c85a1891225fd57f738b611af69db8e4a05fee20637ad1b0589adca66",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [46],
    "primaryOutputId": 46,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 4,
    "actionKey": "057d372e418b7d9627edf6c4e98ef3bfe0c134f1986217b1190091fc75bc2c15",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [36],
    "outputIds": [47],
    "primaryOutputId": 47,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 4,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [37],
    "outputIds": [54],
    "primaryOutputId": 54,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 4,
    "actionKey": "8187072e458458c0c67e369d3f265f8b1490a8e273d295c743bd93b0ba01c5ec",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [55],
    "primaryOutputId": 55,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_randomization_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_randomization_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 4,
    "actionKey": "978cc870f4e285c1b35bce08f5995d88bdb409d77c82f57868534166586dba0c",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [45],
    "outputIds": [56],
    "primaryOutputId": 56,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 4,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [47],
    "outputIds": [57, 58],
    "primaryOutputId": 57,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 5,
    "actionKey": "4f7f3ec64daac87a67ff20550ad2c5e4fe2b9ef14f0498a4a470d4a129e56512",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [59],
    "primaryOutputId": 59,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/python_version_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/python_version_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 5,
    "actionKey": "1042f74c9ae0799d75891a18e9b8597159e63dce1be306048fb344d969877f29",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [60],
    "primaryOutputId": 60,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 5,
    "actionKey": "e60ebd27c34ad4d87beaf736af3961ace6204ad12f200e66cde978bbe43a59e6",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [48],
    "outputIds": [61],
    "primaryOutputId": 61,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 5,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [49],
    "outputIds": [63],
    "primaryOutputId": 63,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 5,
    "actionKey": "bd982c21d9eeeabcf9e93ae856d4170c41319e04a086e95c2a0319ecd90f2118",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [64],
    "primaryOutputId": 64,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/python_version_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/python_version_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 5,
    "actionKey": "c060819ef568a2c718b80f03416d8bb4f4e2a4a303c522c33ff49f98f3008e33",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [53],
    "outputIds": [65],
    "primaryOutputId": 65,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 5,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [55],
    "outputIds": [66, 67],
    "primaryOutputId": 66,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 6,
    "actionKey": "263ed7876e432037903dd39e997a8beff0e933f9f1d36362606223cc8e25d32c",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [68],
    "primaryOutputId": 68,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 6,
    "actionKey": "0f02b17624823eac0fb2ad5dfbe3c0b7b6c55f6ee9398abf2a7c3b73dca7fed3",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [69],
    "primaryOutputId": 69,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 6,
    "actionKey": "ecf6a1ae888dedcb70ce167d47f32825817e2487c407cad575db7a12d0d7754e",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [56],
    "outputIds": [70],
    "primaryOutputId": 70,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 6,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [57],
    "outputIds": [72],
    "primaryOutputId": 72,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 6,
    "actionKey": "35eb742c5653ba0fc000e27ade34a51ac6438e27c74c9a02b42de5d6abc1f13d",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [73],
    "primaryOutputId": 73,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 6,
    "actionKey": "83947ce1bb7ba91bc55b3554c60795b438c116ad3422c707d23066a9a431bfa4",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [61],
    "outputIds": [74],
    "primaryOutputId": 74,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 7,
    "actionKey": "7dad2bf17a9fcc2e6cb50989258d60d7f37d164e08f3907a96bcb544a33511bf",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [75],
    "primaryOutputId": 75,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_sharding_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_sharding_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 7,
    "actionKey": "d27b611adeaef68cd67d551780921060afeec3ffca49cf3a4e4c5891cf6acff5",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [76],
    "primaryOutputId": 76,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 7,
    "actionKey": "ece5bfb4e88f3612e97d8b4d370ddf95c3e210a326f968e4c12ac2376d3e415a",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [63],
    "outputIds": [77],
    "primaryOutputId": 77,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 7,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [64],
    "outputIds": [81],
    "primaryOutputId": 81,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 7,
    "actionKey": "2d7bd345e5ad7cfbe388d062f72fa89d5ecb22f3c2d7c341ff5cd355cb29b5d1",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [82],
    "primaryOutputId": 82,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_sharding_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_sharding_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 7,
    "actionKey": "220a93f133c0ecef4c1e8394783150311a207b03955c59cf4a414e48820b1348",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [70],
    "outputIds": [83],
    "primaryOutputId": 83,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 7,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [72],
    "outputIds": [84, 85],
    "primaryOutputId": 84,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 8,
    "actionKey": "808db07d50ffed9c75420da7b8ce556d9530001bab181bc2fe0d758621a99eb9",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [86],
    "primaryOutputId": 86,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 8,
    "actionKey": "9b53ac4e87b010119aacd2c1f2f75986109da8503114071ddc3db89990b7443e",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [87],
    "primaryOutputId": 87,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 8,
    "actionKey": "a5b505383f1dcce942f5763bec7dbb22d62fae01df1daea192482160b52ef999",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [73],
    "outputIds": [88],
    "primaryOutputId": 88,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 8,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [74],
    "outputIds": [90],
    "primaryOutputId": 90,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 8,
    "actionKey": "afba33fe48fd59ee3c3ed7e9961b266741f1bfb2a656f619471544702cd4a9bc",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [91],
    "primaryOutputId": 91,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 8,
    "actionKey": "6a4534d31e0d5e334b45cf42e611b7824322f8004a0bb3a437e2e7f490b982a3",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [78],
    "outputIds": [92],
    "primaryOutputId": 92,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 8,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [80],
    "outputIds": [93, 94],
    "primaryOutputId": 93,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 9,
    "actionKey": "0cc9315fc43b9a802c614b5964ebc1dabbedf9d2e19ab715baeafd419a7c70f1",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [95],
    "primaryOutputId": 95,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/log_before_import_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/log_before_import_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 9,
    "actionKey": "dba970219781732ccea9869af9fab0a8b54045f4f7dc6843021089dad3ea77d4",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [96],
    "primaryOutputId": 96,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 9,
    "actionKey": "09c9ecabd0434b0733bc6a62eba99d7c2731f160e7c424afca98b56f07646a07",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [81],
    "outputIds": [97],
    "primaryOutputId": 97,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 9,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [82],
    "outputIds": [99],
    "primaryOutputId": 99,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 9,
    "actionKey": "4648b6765273bca27e880eb5fc8bd725f0ee8cb4a1f4874e5cfbf20c0f3650b3",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [100],
    "primaryOutputId": 100,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/log_before_import_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/log_before_import_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 9,
    "actionKey": "6fb593a1ab0f639ecd9b816b45cbda22695a5599b14fdf5a5999d714f79f52b6",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [86],
    "outputIds": [101],
    "primaryOutputId": 101,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 9,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [88],
    "outputIds": [102, 103],
    "primaryOutputId": 102,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 10,
    "actionKey": "3d1a29e82fb9a5351ceefb1f50c9be96d7400bd5cdbc7a98c65dfd6a22d9d768",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [104],
    "primaryOutputId": 104,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_filtering_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_filtering_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 10,
    "actionKey": "06ba9d2424d6d7abe6d59dbbec029b87a2e350d278564805c5a9e177e22b77a0",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [105],
    "primaryOutputId": 105,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 10,
    "actionKey": "21d8831e9f94294811b95b6d6b6e77f2db0f6029a4a3ffd198cb0ba647d74eb8",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [89],
    "outputIds": [106],
    "primaryOutputId": 106,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 10,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [90],
    "outputIds": [108],
    "primaryOutputId": 108,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 10,
    "actionKey": "ef46e29d21b302d8d3a9c10c4253e986e1db9170c0dcbb5a34368352c4d65d24",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [109],
    "primaryOutputId": 109,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_filtering_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_filtering_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 10,
    "actionKey": "8fc1bfd1a988667e8f01271b7446010e54121698a87d02fa967f7590c3b7540d",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [94],
    "outputIds": [110],
    "primaryOutputId": 110,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 11,
    "actionKey": "02877853ff10562d2c1e2f8a29138158fa85860a9903254bfa5ad9492cbbdfcb",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [111],
    "primaryOutputId": 111,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 11,
    "actionKey": "2c859e0f26e5ff22dcecebb33275fb9bf21e0bd5f91bf55a39d023adc2afcf29",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [112],
    "primaryOutputId": 112,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 11,
    "actionKey": "ffdca87f52e8d2c3d6ed5c34cbba6a85002c2eb14865ac8a4d7350c40620c7f3",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [96],
    "outputIds": [113],
    "primaryOutputId": 113,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 11,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [97],
    "outputIds": [118],
    "primaryOutputId": 118,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 11,
    "actionKey": "05af2b454f8bf3436dd9dfe30b73655729a63327967582a4f07161dabfae2113",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [119],
    "primaryOutputId": 119,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 11,
    "actionKey": "dcdd9b7905a0e0e2023fa6336cf1a0d5b5a92fbc448759cb72ca55045bf6f5a0",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [104],
    "outputIds": [120],
    "primaryOutputId": 120,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 11,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [106],
    "outputIds": [121, 122],
    "primaryOutputId": 121,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 12,
    "actionKey": "7a187255d06d81ea25dfc9108f9d0eaa32d36ae146e7f6818692bd287adff6f5",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [123],
    "primaryOutputId": 123,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/verbosity_flag_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/verbosity_flag_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 12,
    "actionKey": "a864e7f6de72469020f082a527d4991d4e39c514d9a95f0283ade31beebd5292",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [124],
    "primaryOutputId": 124,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 12,
    "actionKey": "f837216fe013c81106e3641e9186bbecff55515b5d43c443208cd10123259d48",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [107],
    "outputIds": [125],
    "primaryOutputId": 125,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 12,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [108],
    "outputIds": [127],
    "primaryOutputId": 127,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 12,
    "actionKey": "a5944f750e236ccdab6c7775c0e6807f4ede193d85dbb5f1644173837fe3d123",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [128],
    "primaryOutputId": 128,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/verbosity_flag_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/verbosity_flag_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 12,
    "actionKey": "e5f56658a94f3274aa87805ef1e562850cad319ee77a04e7d8f209f660f3ccfc",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [112],
    "outputIds": [129],
    "primaryOutputId": 129,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 12,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [114],
    "outputIds": [130, 131],
    "primaryOutputId": 130,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 13,
    "actionKey": "174ba818840655009bbab32746b1b95c90830c75c99adff473a687fc2f70ffef",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [132],
    "primaryOutputId": 132,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_formatting_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_formatting_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 13,
    "actionKey": "11c48d5d6159c6b955b57e9dc80dffda0c396c5a1900107eb5d2be1548d7fa9a",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [133],
    "primaryOutputId": 133,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 13,
    "actionKey": "764e0a4899ff7175ec13fca06e71235ce669bf8eeef0cbc0315317d3e305d629",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [115],
    "outputIds": [134],
    "primaryOutputId": 134,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 13,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [116],
    "outputIds": [136],
    "primaryOutputId": 136,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 13,
    "actionKey": "904cc92d2b5a27bc7a8893cf1e1b685776111e75014ff8fef13a589cb94a06e8",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [137],
    "primaryOutputId": 137,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_formatting_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_formatting_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 13,
    "actionKey": "a9cdb5055046937a149f1f06ca233a86e7bc1b36b805422c868a18714f2ae749",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [120],
    "outputIds": [138],
    "primaryOutputId": 138,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 13,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [122],
    "outputIds": [139, 140],
    "primaryOutputId": 139,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 14,
    "actionKey": "882e419851dc6b60c3dba5f2b8fe2c6c5a906f4cf946a801f8930f5fef88fbea",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [141],
    "primaryOutputId": 141,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/app_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/app_test_helper_pure_python"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 14,
    "actionKey": "361f8732929db9048f9777a4ab57a994f9f68937f7e8bd50aa6c6592b7981163",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [142],
    "primaryOutputId": 142,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 14,
    "actionKey": "7290028491bf1ac82980bcd2052a129d1e87a61593c968ab758cc7f127a9cbc9",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [123],
    "outputIds": [143],
    "primaryOutputId": 143,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 14,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [124],
    "outputIds": [145],
    "primaryOutputId": 145,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 14,
    "actionKey": "552f8ca7836841f687e86e2aa9ade98a0f7dc60747c93973c531d71634995d5a",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [146],
    "primaryOutputId": 146,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/app_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/app_test_helper_pure_python"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 14,
    "actionKey": "2f1bcef82632ba37df295d1aa080ad0c08bac5d3ebcfeb5268f8e00ea9032b53",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [128],
    "outputIds": [147],
    "primaryOutputId": 147,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 15,
    "actionKey": "6bd7513368e411bd937c1615f1729842264fd60d3314d5fc1db2f9bb972a1a4b",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [148],
    "primaryOutputId": 148,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_fail_fast_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_fail_fast_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 15,
    "actionKey": "4a4558469f5e0c73cc8f71a8233bce76569170db651a707dd9415b11323a06ef",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [149],
    "primaryOutputId": 149,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 15,
    "actionKey": "af3f67f5d276db128d2e03205f41f36578d985a0a442dcee026138eb6a07597d",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [130],
    "outputIds": [150],
    "primaryOutputId": 150,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 15,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [131],
    "outputIds": [152],
    "primaryOutputId": 152,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 15,
    "actionKey": "e63b11f5314ba69c7719f5a9945982cb62ceeb2db3a4c4c7ed734f3261ebd4a7",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [153],
    "primaryOutputId": 153,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_fail_fast_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_fail_fast_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 15,
    "actionKey": "90ecc3f308a7b6f3ffe1e1a458635352a21caeb5500999594d5327d7da89739b",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [135],
    "outputIds": [154],
    "primaryOutputId": 154,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 15,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [137],
    "outputIds": [155, 156],
    "primaryOutputId": 155,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 16,
    "actionKey": "e88e2f99cbb2c4409e1deea18be1d06a4b7406f3868742e80bfe6c7d091363c6",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [157],
    "primaryOutputId": 157,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_helpers_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_helpers_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 16,
    "actionKey": "741ec568ad0d569932d9ca94b359f137b32fc480dedecb46ddcf90c0b6879dcc",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [158],
    "primaryOutputId": 158,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 16,
    "actionKey": "03fb4316995a4ce2f3e503dd2e48a8bbf274c4e6fa26985d59a05e22f35efa92",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [138],
    "outputIds": [159],
    "primaryOutputId": 159,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 16,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [139],
    "outputIds": [161],
    "primaryOutputId": 161,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 16,
    "actionKey": "854d96b84c3ee7c28b065c6395b916a47183be972d4ae9e04ec84e0cadd68a18",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [162],
    "primaryOutputId": 162,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_helpers_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_helpers_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 16,
    "actionKey": "8fd2dcfd7c1066625575500fa2b6b78031c6a5aef44f278591931adb58e27ad2",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [143],
    "outputIds": [163],
    "primaryOutputId": 163,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 16,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [145],
    "outputIds": [164, 165],
    "primaryOutputId": 164,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "7c6aa24aaabd3e98d08337d31edd06f26b79e34e99b02274dd35dcb6a7556d5a",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [166],
    "primaryOutputId": 166,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_functional_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_functional_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 17,
    "actionKey": "ebf9f4275a720275194e8db691bc4a3c2d8f618bec29a4655aa6a605b94c045a",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [167],
    "primaryOutputId": 167,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "3fcedcab661df78b3d5ca39e61eecc0a7f82a1ccb434f9618ca90a8001bd17ac",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [146],
    "outputIds": [168],
    "primaryOutputId": 168,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [147],
    "outputIds": [172],
    "primaryOutputId": 172,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "03554e5608fcf082de97f7e43bd95056e60034622e693f4c6dfe32b95392b1b1",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [173],
    "primaryOutputId": 173,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_functional_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_functional_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 17,
    "actionKey": "a20342b0a2f63adde3d8b112fb2fd04276bcb155ca8256b9f7f824d67ce9d562",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [153],
    "outputIds": [174],
    "primaryOutputId": 174,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "70170694265bfae4d3fe658b4e9e5939322977e6fce415c85c70d751902b99a5",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [175, 176],
    "primaryOutputId": 175,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "5cb7a56203713a57d890ef89726b5feb3244a9254c6e96c41449d1966d41e227",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [177, 178],
    "primaryOutputId": 177,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "e610af6f2cd1f1a68aaf0cffc32f5fbfe2d5ac205291db35da3f8e49977d9650",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [179, 180],
    "primaryOutputId": 179,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "8cffc73542a40d63f9dc071a7cc0597f004d4816c8e4b5baf29c01e029b48806",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [181, 182],
    "primaryOutputId": 181,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "cff3bbae5aa15222c7bf20f37b7428a35558acb703edaf23ccb4850b247aee1e",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [183, 184],
    "primaryOutputId": 183,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "c6722826b15c464062a2f7e8e11f92ad2b5182522679fe3695f2af91900dbb8b",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [185, 186],
    "primaryOutputId": 185,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "19a83d8f956ff748f76a9c56ca5cfa7c746f69f0258a70b6caf84901f61d1c81",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [187, 188],
    "primaryOutputId": 187,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "2242f8af6fdb3b22d45d01a835eeb4e4037a7c44ef2439d43cb697d7ec5dad38",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [189, 190],
    "primaryOutputId": 189,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "95cad06abbabc702dab009e43a9846a63fa3586afeb7d0c8c6308c56a08e35db",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [191, 192],
    "primaryOutputId": 191,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "3c84f5c0f9b9ccda391ad438c1f0342fc305c10aab4db3a341416f715694e60a",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [193, 194],
    "primaryOutputId": 193,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "7a78b026f9d3e007e2cbe978d39b7e41cc2c7b21dc9b28c857923f267c135c28",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [195, 196],
    "primaryOutputId": 195,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "a0f6d428a77ccca4c1223961ae826deb6138397612cb6cbd1eb89414702f836a",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [197, 198],
    "primaryOutputId": 197,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "ee5053e44e6821831150931acb28ab11f39fa0e0b199554c34b84fb71a9699e4",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [199, 200],
    "primaryOutputId": 199,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "81786cfbe645a72499ec12dabb26c8c0e2dac24a19bab5ef090892a797014c7a",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [201, 202],
    "primaryOutputId": 201,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "3544860afb89bc7eca574335c4611dc8ef39cb5f56c949806d55bdc2abfea17b",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [203, 204],
    "primaryOutputId": 203,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "787857ea2e047af1777c7b2ef74eeb948480771a152e45230c4a20b3abd99e13",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [205, 206],
    "primaryOutputId": 205,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "a390337757475c3aebcac36878eebbb26bbf4c380943213b6c0bdbc6a082bdbf",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [207, 208],
    "primaryOutputId": 207,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "a48b086ea62878c1d68a50a56029f33598c32e919c7592e86633fe0f3c506a09",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [209, 210],
    "primaryOutputId": 209,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "328a94215cf356408eb4b198f9aaea8cde70eab91e23c13368949f1ba681cbc0",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [211, 212],
    "primaryOutputId": 211,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "b90914c477bb63c4c3008f472234ecc7ff47a3185faa554e82741ee2d61cbffd",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [213, 214],
    "primaryOutputId": 213,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "4fbceafc06b81a5659f08ae6d09c66b5948419945ac9d9d4ecbd0a066bd2d22e",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [215, 216],
    "primaryOutputId": 215,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "dd8dafc7b2b440eef9e4e6cdc90ab854851f31c6d489e053371db4ad4e4b6f35",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [217, 218],
    "primaryOutputId": 217,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "d1218e3b96786659212685c860a47b21689787286bd1690b9f236fef3f4a8147",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [219, 220],
    "primaryOutputId": 219,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "118bef32df3b32de17cdf8b4b8d799cb8e641e7d4048fbaed3b82b19660c0651",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [221, 222],
    "primaryOutputId": 221,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "1f4a15882b7bb8fbdc3308cfe990fc7de9f2707f08f57e439588c47d862a9df3",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [223, 224],
    "primaryOutputId": 223,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "12680760f53a3824c00b911b2a8797b395e86712204400fe4e7388b5c2bcd60e",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [225, 226],
    "primaryOutputId": 225,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "51d64448ccea74ad4b8218eb4474f25dd3e8a2e875774ebc6911c3e9a562724b",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [227, 228],
    "primaryOutputId": 227,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "edf4d55a4d15e327c53bb28877bb9b38ff5aa7684d4c39c7b825f8bdccd1abb3",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [229, 230],
    "primaryOutputId": 229,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "141ce94022c87693f5460831e95d3e8fadd16aa14e20529d4370dc7b0e5451ad",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [231, 232],
    "primaryOutputId": 231,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "be8cdb03db8001eea03dec88068df2182a7d335490e5a3ad48b04b1af14db621",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [233, 234],
    "primaryOutputId": 233,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "fddc3ee504252ead3d13957ce2a38dc349f55a76c674a8e111caeb322dfb9e27",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [235, 236],
    "primaryOutputId": 235,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "5624d8d670e782c2fbeffe1cd4dd3698faa60ccfff4da1d423a69306e5e04a7e",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [237, 238],
    "primaryOutputId": 237,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "40c5e72e93e95cb371bfe8a489675615f730ecd619e47798e86e406ace4ff717",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [239, 240],
    "primaryOutputId": 239,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "ff21a214d88f2fbffd2c29077d350688da4e3ec0310f7a199c5c2d78625161aa",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [241, 242],
    "primaryOutputId": 241,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "8434b35a5f1865b1ff756330e4ebb4bf9236693d77f0d9c121e8714cc4b55af2",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [243, 244],
    "primaryOutputId": 243,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "09504efc11c6154df7adb5acc7c00e36896bf89b7b77b3cf220207a3ceefa604",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [245, 246],
    "primaryOutputId": 245,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "62bf8cf0fefca8e3266dd1bf1d727ac9ce1da60f68f0d51be1682c0d853c0302",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [247, 248],
    "primaryOutputId": 247,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "82d7056af6b80ad36438c8c876f4525121307431200ea19f2f96667d1cf1beba",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [249, 250],
    "primaryOutputId": 249,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "b0ccf0f97c718dadfd88cfda7ace0aacde52dfcf689ce003d312f492dbf7f5c8",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [251, 252],
    "primaryOutputId": 251,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "8bceea54c649d2f971458f45d12c9a2698b2dd20166afdc31e9be1433a80029e",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [253, 254],
    "primaryOutputId": 253,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "79ee1458866648cbcacff13d3ca79ee3d60717b375314522f6e2de802190a781",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [255, 256],
    "primaryOutputId": 255,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "b9f8444d0fc5578d6b693b20f992c674b0b0cdc8522d5e69f61561ffd665cce6",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [257, 258],
    "primaryOutputId": 257,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "cf5cb4890b05457515aaa744ec31f1a9bc70efc41f370d418dbecfda384eb6f7",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [259, 260],
    "primaryOutputId": 259,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "1a4fddddc053f477a79c453cadb216f1c546b6f4222d824871b89a94e882657a",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [261, 262],
    "primaryOutputId": 261,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "1d9d38c5e670bc9413e333fc2f725e8c8424d45597b47b64f84986dded5a2b11",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [263, 264],
    "primaryOutputId": 263,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "b95c9787b265ac1c7899d9bc7d83462203e16a11a333c25c36b7dfc329311985",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [265, 266],
    "primaryOutputId": 265,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "efc0c3633ce31d1b349db2aaa17faeb83a1598ea7a648292efc7168c5806e73d",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [267, 268],
    "primaryOutputId": 267,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "80b4755658d3689b8b06166441bb9e6ade9513987c92692f8f221a8076ca50b0",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [269, 270],
    "primaryOutputId": 269,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "a4a89f49bed9270aa34a26da607343c5a10be74d4a5a90148c1fbe1c84766e4b",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [271, 272],
    "primaryOutputId": 271,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 17,
    "actionKey": "ccc188e70b66156905b3a29e80d6918de732c2a98acae71561cf6d34bea12bb6",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [155],
    "outputIds": [273, 274],
    "primaryOutputId": 273,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 18,
    "actionKey": "39b1786f2ebcc50f5559169cd02f73b83306ec07173d3e240ae4cbe70144b142",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [275],
    "primaryOutputId": 275,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/argparse_flags_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/argparse_flags_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 18,
    "actionKey": "52b978626135af71371bcd07c57e8413a43f4f144c30ca47e6404a135cc7df22",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [276],
    "primaryOutputId": 276,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 18,
    "actionKey": "f1768327a567d91a222008c023db8e36b3f0bdc218d61dfb2a67ac1e3f61fd0a",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [156],
    "outputIds": [277],
    "primaryOutputId": 277,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 18,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [157],
    "outputIds": [279],
    "primaryOutputId": 279,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 18,
    "actionKey": "ab0ef681eb792ed411f3dd81a6fe82d1d5bfaf3d63caba4107a89b908be109b7",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [280],
    "primaryOutputId": 280,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/argparse_flags_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/argparse_flags_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 18,
    "actionKey": "01188d3feb9f8b31e8d9b686d10e44c7f2ebd45d28c0cbc5b7cfb2ea2aa90feb",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [161],
    "outputIds": [281],
    "primaryOutputId": 281,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 18,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [163],
    "outputIds": [282, 283],
    "primaryOutputId": 282,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 19,
    "actionKey": "e9270d4f2e01b4cd6a0ec08d0977af11b6fe0cac4f2d9130039f896eaf015809",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [284],
    "primaryOutputId": 284,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_argument_parser_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_argument_parser_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 19,
    "actionKey": "ffd0559f0f9944199126e190481e8035d275dfe2445394afb8ff830b5b59af7f",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [285],
    "primaryOutputId": 285,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 19,
    "actionKey": "395add9fd7df62869cab8c1c88c47029c1fda5876b53900080c899154fefb6fb",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [164],
    "outputIds": [286],
    "primaryOutputId": 286,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 19,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [165],
    "outputIds": [288],
    "primaryOutputId": 288,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 19,
    "actionKey": "8c635e60c54d8e8df0662f6a221b3cae0150f8c990e0aaac447641b8ec89ade2",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [289],
    "primaryOutputId": 289,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_argument_parser_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_argument_parser_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 19,
    "actionKey": "a9dd0274b74b4c895d1dbb1382b029c1946a3a908b9291b7cdf556b15d1e22ce",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [169],
    "outputIds": [290],
    "primaryOutputId": 290,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 19,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [171],
    "outputIds": [291, 292],
    "primaryOutputId": 291,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 20,
    "actionKey": "78f61d16fbcf29812b794707cf36fd2a01f999f072befc411b7255e7aa4f913b",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [293],
    "primaryOutputId": 293,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_flag_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_flag_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 20,
    "actionKey": "d01f9c184434cb5f85986b8b3c68b9fe495da6cd3b60fc5671a176a8dbbec03f",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [294],
    "primaryOutputId": 294,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 20,
    "actionKey": "dc4ea6a7d38d159820b3c0d838333d681e0a72d4df4f16b5d4193e07cac07ded",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [172],
    "outputIds": [295],
    "primaryOutputId": 295,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 20,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [173],
    "outputIds": [297],
    "primaryOutputId": 297,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 20,
    "actionKey": "411f74aa2023397ce4b711dc6ed7233544e752b088b9c619716fc7017341abf5",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [298],
    "primaryOutputId": 298,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_flag_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_flag_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 20,
    "actionKey": "5637c090bc34babe751c77f10bfdda5539c6ee0cdb7f63c707fc5fe3b46aafbc",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [177],
    "outputIds": [299],
    "primaryOutputId": 299,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 20,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [179],
    "outputIds": [300, 301],
    "primaryOutputId": 300,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 21,
    "actionKey": "209e0e24b23a65af4d6df5276b1e6d836b836eb2f1b6453a4b9fbc6f1dcc164f",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [80],
    "primaryOutputId": 80,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_sharding_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_sharding_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 21,
    "actionKey": "4f3fa5f245e9b17febbfc08d000dfae363b1fe3e2e5d8629faade61c2424315c",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [302],
    "primaryOutputId": 302,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 21,
    "actionKey": "87c6e62722aed4e187e7051d4e78142e087a766f2dfa088847e366949aec98ed",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [180],
    "outputIds": [303],
    "primaryOutputId": 303,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 21,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [181],
    "outputIds": [304],
    "primaryOutputId": 304,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 21,
    "actionKey": "bbd0bf9405c40c123154dd16e49203553abba9a968d34dc95d28d63aaafeaa30",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [305],
    "primaryOutputId": 305,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_sharding_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_sharding_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 21,
    "actionKey": "c012cb64459e90acbd3cdb7cfc5b7c19cfacc8906e559abfcce7fdf7c9cc33bd",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [183],
    "outputIds": [306],
    "primaryOutputId": 306,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 22,
    "actionKey": "7dd48a6237e75297351e0734b100bfa0047f71098f2f635a282fed326188a709",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [307],
    "primaryOutputId": 307,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_flagvalues_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_flagvalues_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 22,
    "actionKey": "da7ab21624a3c35a91b94292abc95976915b35a762243ecaed23cbe87fac7f02",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [308],
    "primaryOutputId": 308,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 22,
    "actionKey": "4a5f8ee5cba559615cc43980a66f2464f050b29f03be6daac135b2529c659ede",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [185],
    "outputIds": [309],
    "primaryOutputId": 309,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 22,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [186],
    "outputIds": [311],
    "primaryOutputId": 311,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 22,
    "actionKey": "e15f6992b25d0fdccd312e5d26fdfbcc411d11154b3aba6aacacfe437fc62612",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [312],
    "primaryOutputId": 312,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_flagvalues_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_flagvalues_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 22,
    "actionKey": "9c1505f53dd8cca32151262a5b5ace995baaeb5db062dd5b5480dcddb5fe3222",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [190],
    "outputIds": [313],
    "primaryOutputId": 313,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 22,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [192],
    "outputIds": [314, 315],
    "primaryOutputId": 314,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 23,
    "actionKey": "d7f30cd9b14d055df6667581617a153506d5bf6549a3ba8e66c54ca500da50c0",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [316],
    "primaryOutputId": 316,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/converter_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/converter_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 23,
    "actionKey": "187c76f2181544c213f549f3ba50eecb8331472b19f9d53c7f1ec8b796cf360d",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [317],
    "primaryOutputId": 317,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 23,
    "actionKey": "af4eefa6c8a99bde844a7082b84ad28cfd17944738451b23769ddd995f8a6231",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [193],
    "outputIds": [318],
    "primaryOutputId": 318,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 23,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [194],
    "outputIds": [320],
    "primaryOutputId": 320,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 23,
    "actionKey": "9293b3102eb7416ce25e5147fb8b8c371371590f590e232e1722d1593a149aa6",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [321],
    "primaryOutputId": 321,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/converter_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/converter_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 23,
    "actionKey": "1f4e1852683c9592c7f6c4b047c4be3e26d528c1d53c02c816171baab6549f5b",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [198],
    "outputIds": [322],
    "primaryOutputId": 322,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 23,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [200],
    "outputIds": [323, 324],
    "primaryOutputId": 323,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 24,
    "actionKey": "4e4d69a03203a595709cc082b2e744de7ad0532568ae366afaede6324141b47b",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [171],
    "primaryOutputId": 171,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_functional_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_functional_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 24,
    "actionKey": "344bba990d76a4fd63addb254412bcc154d3052aeffb92cfd9039e204b14ec11",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [325],
    "primaryOutputId": 325,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 24,
    "actionKey": "d355bab928b5db2d814f07f13825d61669888cf8cb301165219064e018e5556c",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [201],
    "outputIds": [326],
    "primaryOutputId": 326,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 24,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [202],
    "outputIds": [327],
    "primaryOutputId": 327,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 24,
    "actionKey": "bf5c957c7655eb6952be5d7e2167bc9cc32bd75673896605927b946410ba748c",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [328],
    "primaryOutputId": 328,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_functional_test_helper.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_functional_test_helper"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 24,
    "actionKey": "5e69a15f5a427e07a9f1bfa6b349751c2adbdc996c4975f334e0d8978bf80d54",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [204],
    "outputIds": [329],
    "primaryOutputId": 329,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 25,
    "actionKey": "230f421205b4ab9105eeb515f191b5909dc028e5fe660ab9a68dd346a4879653",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [330],
    "primaryOutputId": 330,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/xml_reporter_helper_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/xml_reporter_helper_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 25,
    "actionKey": "8a28196f4b28435500346372e3bae5940ab3a5742050ac0529eca434ce908278",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [331],
    "primaryOutputId": 331,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 25,
    "actionKey": "a0d42bc977248ab265f5c61a43563d0ad5de1ffd6e3e659c8d83975658eb0888",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [206],
    "outputIds": [332],
    "primaryOutputId": 332,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 25,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [207],
    "outputIds": [334],
    "primaryOutputId": 334,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 25,
    "actionKey": "385f7ac542acc0c1eb4787128bdad3a2be29ed01ddd3a0774466b3f512f392d0",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [335],
    "primaryOutputId": 335,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/xml_reporter_helper_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/xml_reporter_helper_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 25,
    "actionKey": "13f354b6503983292360ac3825728115c811b8bd2e01f8258314ef1a3449b2ed",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [211],
    "outputIds": [336],
    "primaryOutputId": 336,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 26,
    "actionKey": "9efd2e4d86182bfc72e15e4f41873e6493b6815f252260306eeb9a8a0eca7ea0",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [337],
    "primaryOutputId": 337,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_validators_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_validators_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 26,
    "actionKey": "b506624f56a6ff9db0224d4c721a7df600159f28b1c68f65aa720fd5b8d47a6e",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [338],
    "primaryOutputId": 338,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 26,
    "actionKey": "2903e7e18801798e9ffd126131d015c84eafed1d5a274a660b16ccca50f05cec",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [213],
    "outputIds": [339],
    "primaryOutputId": 339,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 26,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [214],
    "outputIds": [341],
    "primaryOutputId": 341,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 26,
    "actionKey": "e9cff054df85b5ec69d0e347e9baaaa1cabe0d7bb6f480fa254b7c2a5ffae04e",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [342],
    "primaryOutputId": 342,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/_validators_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/_validators_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 26,
    "actionKey": "fc9b7db47575b4b72f5774eee2ab8699fd7de7961f4f69d9c85a6d9e557edc66",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [218],
    "outputIds": [343],
    "primaryOutputId": 343,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 26,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [220],
    "outputIds": [344, 345],
    "primaryOutputId": 344,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 27,
    "actionKey": "b80de66fd124f7e8724478a0d9f8daf44bf5524978e95ab0dfe12076ea381e49",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [346],
    "primaryOutputId": 346,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/parameterized_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/parameterized_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 27,
    "actionKey": "bb80454e5bef4b8d9988adda676b6153808e75406b0868110bea6d751298844f",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [347],
    "primaryOutputId": 347,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 27,
    "actionKey": "c010fb39c2f1f5bca81a64ab211efd6784590e4592b6591a1f7f55ec8d414c82",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [221],
    "outputIds": [348],
    "primaryOutputId": 348,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 27,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [222],
    "outputIds": [350],
    "primaryOutputId": 350,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 27,
    "actionKey": "7011581d1b5eb7c02f1af1821effa307473457ab2bbab774f09df0a60265f751",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [351],
    "primaryOutputId": 351,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/parameterized_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/parameterized_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 27,
    "actionKey": "0d13a4f30896ee8b545b8d443508ca329c48d22be777b0c6c3ee39694575521a",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [226],
    "outputIds": [352],
    "primaryOutputId": 352,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 27,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [228],
    "outputIds": [353, 354],
    "primaryOutputId": 353,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 28,
    "actionKey": "d75a6ce1c57b1f7530510c84568ba718b4036a9396a5ac3a4e0c276ef7980ad0",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [355],
    "primaryOutputId": 355,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 28,
    "actionKey": "1b35ff00423169571d9e81af80e324512c7641ddcfadaa663445ff72ff84a0d8",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [356],
    "primaryOutputId": 356,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 28,
    "actionKey": "a13882ca6b4460bf6d0af0a783707439db895c77d6b6c415d46033ad173b4419",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [229],
    "outputIds": [357],
    "primaryOutputId": 357,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 28,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [230],
    "outputIds": [360],
    "primaryOutputId": 360,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 28,
    "actionKey": "d54d2054594098c562695720de2992183526e32e2b99b48c6a1b6be9c63b3906",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [361],
    "primaryOutputId": 361,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/logging/tests/logging_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/logging:tests/logging_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 28,
    "actionKey": "3e840eef58b46ef85629d2f973f069c1c0ca04f9f8ba4701ad9604dc3093cb41",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [235],
    "outputIds": [362],
    "primaryOutputId": 362,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 28,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [237],
    "outputIds": [363, 364],
    "primaryOutputId": 363,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 29,
    "actionKey": "9823dce612e9a9192d617a31ce04ea63351a95f2d4b0bfa7ac79f355a6c91e5f",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [365],
    "primaryOutputId": 365,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_helpxml_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_helpxml_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 29,
    "actionKey": "1719a7670e13f7c05bc0a2f2d7d069d7185cfacd5f990c9e1c6e7ec5266dfaa0",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [366],
    "primaryOutputId": 366,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 29,
    "actionKey": "8f125f07b960adb510ea2a66f2331ae99be387f431709ee5a6b95cebe4c52478",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [238],
    "outputIds": [367],
    "primaryOutputId": 367,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 29,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [239],
    "outputIds": [369],
    "primaryOutputId": 369,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 29,
    "actionKey": "07feed7451637e9e6d54ff405590b8c6bbcbc4d2329fc1b5283556f9a09d5243",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [370],
    "primaryOutputId": 370,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_helpxml_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_helpxml_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 29,
    "actionKey": "46fca22d9bfd303ed922d60fcdbec1c5623da649c4053f4603bef2693abdfa4b",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [243],
    "outputIds": [371],
    "primaryOutputId": 371,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 29,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [245],
    "outputIds": [372, 373],
    "primaryOutputId": 372,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 30,
    "actionKey": "4cadf3825632e99988735f15b92fb6192e9181433751b8710d024fa0727fd82c",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [50],
    "primaryOutputId": 50,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_randomization_testcase.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_randomization_testcase"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 30,
    "actionKey": "a301f26a46a55351f1ad5e2ebc648393f1f402b3942b83a6345a08bfb0115f1d",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 1,
    "outputIds": [374],
    "primaryOutputId": 374,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 30,
    "actionKey": "420d609b794f2166ee45e8d2c6f1312c29f92989b222f67b2b9b46658912558b",
    "mnemonic": "SymlinkTree",
    "configurationId": 1,
    "inputDepSetIds": [246],
    "outputIds": [375],
    "primaryOutputId": 375,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 30,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 1,
    "inputDepSetIds": [247],
    "outputIds": [376],
    "primaryOutputId": 376,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 30,
    "actionKey": "27c573971aa161b5b9330b2306160b8a206b96fc7b168390d477962a68629f93",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "outputIds": [377],
    "primaryOutputId": 377,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_randomization_testcase.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_randomization_testcase"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 30,
    "actionKey": "ba7356ab49bf2a88750192ca75b8253ff6fec69d838a4702dd19efff177cd312",
    "mnemonic": "PythonZipper",
    "configurationId": 1,
    "inputDepSetIds": [249],
    "outputIds": [378],
    "primaryOutputId": 378,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 31,
    "actionKey": "858adea8d44b036876a1f01b5283a49be428a5b21cf43ccf7900778fbfa6c678",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [379],
    "primaryOutputId": 379,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_numeric_bounds_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_numeric_bounds_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 31,
    "actionKey": "e7f8ed542bb976f9db1b5075207f3ec12bbb5a678e892d92656796b865c41263",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [380],
    "primaryOutputId": 380,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 31,
    "actionKey": "ddf21273234490c461d90b387fe12829dabe7c8b7d26e1266d17abc46e8234d6",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [251],
    "outputIds": [381],
    "primaryOutputId": 381,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 31,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [252],
    "outputIds": [383],
    "primaryOutputId": 383,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 31,
    "actionKey": "dc58e35c2e69285a8cf9cf3ef0a054101ef3b06466f10dcd149efc21127ad31d",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [384],
    "primaryOutputId": 384,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/flags/tests/flags_numeric_bounds_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/flags:tests/flags_numeric_bounds_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 31,
    "actionKey": "b868d41f19565d45b3aabac8b51e74de42df199c932365daa44204dfc447987b",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [256],
    "outputIds": [385],
    "primaryOutputId": 385,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 31,
    "actionKey": "11f9bcb477e75a21268044a53365ebb56645aa9dda77ba2e2a4d9f51d73ccbc1",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [258],
    "outputIds": [386, 387],
    "primaryOutputId": 386,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 32,
    "actionKey": "4408021a6ae1049ddd49bbef0467b81689902155f4c7211d9049c958df3fa197",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [388],
    "primaryOutputId": 388,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/xml_reporter_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/xml_reporter_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 32,
    "actionKey": "01a65c93485d6683eb3a16be08591cca4df21618cdee8948c9f217f0b458291e",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [389],
    "primaryOutputId": 389,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 32,
    "actionKey": "013afd5687416dd0e86bff5d6aad387e28ddb7f472b0a34f3da0a8ccfa937796",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [259],
    "outputIds": [390],
    "primaryOutputId": 390,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 32,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [260],
    "outputIds": [392],
    "primaryOutputId": 392,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 32,
    "actionKey": "4425263b65fc20ea685de6753d49f11c81dc4271ea7f334ec7255fafef0a025d",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [393],
    "primaryOutputId": 393,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/xml_reporter_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/xml_reporter_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 32,
    "actionKey": "d5329dda8643e2721bc7d5533b577a4f10b731fe52e39fc1988c9e4e49e7f79a",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [264],
    "outputIds": [394],
    "primaryOutputId": 394,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 32,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [266],
    "outputIds": [395, 396],
    "primaryOutputId": 395,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 33,
    "actionKey": "48b06861dbd2413f814fad31b69f3ed283bae4f39d1f07f5603e49cd451eb73d",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [397],
    "primaryOutputId": 397,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/app_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/app_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 33,
    "actionKey": "b4e0d533f19a2e059bcf6b2fc243c8b9eab331825752d3487d39bafead2d6194",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [398],
    "primaryOutputId": 398,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 33,
    "actionKey": "2d85b7cad0f4bc78cded679041c2361817cca187fa07639efd88caab26c6c737",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [267],
    "outputIds": [399],
    "primaryOutputId": 399,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 33,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [268],
    "outputIds": [401],
    "primaryOutputId": 401,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 33,
    "actionKey": "7d8e3bac51d1a214135086f46a5976edcd3a2ab17d46c09542e00b39fb4d7481",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [402],
    "primaryOutputId": 402,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/app_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/app_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 33,
    "actionKey": "5ec568d0b937f3c20c0eddaf9c7766c2e738bd1eeb935ee712fed9688d85ba76",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [273],
    "outputIds": [403],
    "primaryOutputId": 403,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 33,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [275],
    "outputIds": [404, 405],
    "primaryOutputId": 404,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 34,
    "actionKey": "b1f5483aed51362fdc1441b2a1b9922e3f7bbb44d78507a6a276bfdb2114ce0e",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [406],
    "primaryOutputId": 406,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/flagsaver_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/flagsaver_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 34,
    "actionKey": "dcdf1264fff69894d1dc1f7c2924563940a38a23acae2ade5ec2634aa6be6828",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [407],
    "primaryOutputId": 407,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 34,
    "actionKey": "caf731c5914c67e9883e3a8a8bf2de6fadff683c8154c1eefe73f6ffa27dd185",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [276],
    "outputIds": [408],
    "primaryOutputId": 408,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 34,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [277],
    "outputIds": [410],
    "primaryOutputId": 410,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 34,
    "actionKey": "a5a2540c8474328c152a0d1608adcf8cc638ce7b44ea5d0f839d2ebfbd1f25d2",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [411],
    "primaryOutputId": 411,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/flagsaver_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/flagsaver_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 34,
    "actionKey": "2bf2dae36c9d3f8b3a5ea604fe8bed5de9868b316b450e610a73ad399928b919",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [281],
    "outputIds": [412],
    "primaryOutputId": 412,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 34,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [283],
    "outputIds": [413, 414],
    "primaryOutputId": 413,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 35,
    "actionKey": "7cdc711c98dbf9fab03bec1c24c367bba5ae363272e883ff6cb3cc8311b5585b",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [415],
    "primaryOutputId": 415,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_filtering_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_filtering_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 35,
    "actionKey": "70bdc3e2fbf735280a827eeaaa9cf6b0094e71ab05b1b257866d1d7623ffa8df",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [416],
    "primaryOutputId": 416,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 35,
    "actionKey": "2e86c2b18ff1f8e717ba5e9c5311a785582d439266569b85ee0d3f3f0b92f829",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [284],
    "outputIds": [417],
    "primaryOutputId": 417,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 35,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [285],
    "outputIds": [419],
    "primaryOutputId": 419,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 35,
    "actionKey": "91f8768c351105e1dce5842c02a65bfb163579096382f147d6fd39e0c78d2c2d",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [420],
    "primaryOutputId": 420,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/testing/tests/absltest_filtering_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl/testing:tests/absltest_filtering_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 35,
    "actionKey": "580f9f7a390ddffb7ae6a0da45dd81613d37029898143abaf5ad3d7ef79184b6",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [289],
    "outputIds": [421],
    "primaryOutputId": 421,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 35,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [291],
    "outputIds": [422, 423],
    "primaryOutputId": 422,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 36,
    "actionKey": "35593d3de867a1527f891c84920c583b1812ac6ee94f9f1c145c7711b965a1af",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [424],
    "primaryOutputId": 424,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/command_name_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "False"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/command_name_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 36,
    "actionKey": "0d0157f1be42f520488ad8a76c3b20312b6e77ac97cffadc13407290f495b345",
    "mnemonic": "SourceSymlinkManifest",
    "configurationId": 2,
    "outputIds": [425],
    "primaryOutputId": 425,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 36,
    "actionKey": "1b0ff0909c3f9433db134559de232c44644a271998daea0ab850fd08c8a5b0d6",
    "mnemonic": "SymlinkTree",
    "configurationId": 2,
    "inputDepSetIds": [292],
    "outputIds": [426],
    "primaryOutputId": 426,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 36,
    "actionKey": "709e80c88487a2411e1ee4dfb9f22a861492d20c4765150c0c794abd70f8147c",
    "mnemonic": "Middleman",
    "configurationId": 2,
    "inputDepSetIds": [293],
    "outputIds": [428],
    "primaryOutputId": 428,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 36,
    "actionKey": "ab4fba15b5b6d3d3500cd1ff7f8b96892b787099a89c3152f7c80da01f57c612",
    "mnemonic": "TemplateExpand",
    "configurationId": 2,
    "outputIds": [429],
    "primaryOutputId": 429,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "%shebang%\n\n# This script must retain compatibility with a wide variety of Python versions\n# since it is run for every py_binary target. Currently we guarantee support\n# going back to Python 2.7, and try to support even Python 2.6 on a best-effort\n# basis. We might abandon 2.6 support once users have the ability to control the\n# above shebang string via the Python toolchain (#8685).\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\n\n# The Python interpreter unconditionally prepends the directory containing this\n# script (following symlinks) to the import path. This is the cause of #9239,\n# and is a special case of #7091. We therefore explicitly delete that entry.\n# TODO(#7091): Remove this hack when no longer necessary.\ndel sys.path[0]\n\nimport os\nimport subprocess\n\ndef IsRunningFromZip():\n  return %is_zipfile%\n\nif IsRunningFromZip():\n  import shutil\n  import tempfile\n  import zipfile\nelse:\n  import re\n\n# Return True if running on Windows\ndef IsWindows():\n  return os.name \u003d\u003d \u0027nt\u0027\n\ndef GetWindowsPathWithUNCPrefix(path):\n  \"\"\"Adds UNC prefix after getting a normalized absolute Windows path.\n\n  No-op for non-Windows platforms or if running under python2.\n  \"\"\"\n  path \u003d path.strip()\n\n  # No need to add prefix for non-Windows platforms.\n  # And \\\\?\\ doesn\u0027t work in python 2 or on mingw\n  if not IsWindows() or sys.version_info[0] \u003c 3:\n    return path\n\n  # Starting in Windows 10, version 1607(OS build 14393), MAX_PATH limitations have been\n  # removed from common Win32 file and directory functions.\n  # Related doc: https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs\u003dcmd#enable-long-paths-in-windows-10-version-1607-and-later\n  import platform\n  if platform.win32_ver()[1] \u003e\u003d \u002710.0.14393\u0027:\n    return path\n\n  # import sysconfig only now to maintain python 2.6 compatibility\n  import sysconfig\n  if sysconfig.get_platform() \u003d\u003d \u0027mingw\u0027:\n    return path\n\n  # Lets start the unicode fun\n  unicode_prefix \u003d \u0027\\\\\\\\?\\\\\u0027\n  if path.startswith(unicode_prefix):\n    return path\n\n  # os.path.abspath returns a normalized absolute path\n  return unicode_prefix + os.path.abspath(path)\n\ndef HasWindowsExecutableExtension(path):\n  return path.endswith(\u0027.exe\u0027) or path.endswith(\u0027.com\u0027) or path.endswith(\u0027.bat\u0027)\n\nPYTHON_BINARY \u003d \u0027%python_binary%\u0027\nif IsWindows() and not HasWindowsExecutableExtension(PYTHON_BINARY):\n  PYTHON_BINARY \u003d PYTHON_BINARY + \u0027.exe\u0027\n\ndef SearchPath(name):\n  \"\"\"Finds a file in a given search path.\"\"\"\n  search_path \u003d os.getenv(\u0027PATH\u0027, os.defpath).split(os.pathsep)\n  for directory in search_path:\n    if directory:\n      path \u003d os.path.join(directory, name)\n      if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n  return None\n\ndef FindPythonBinary(module_space):\n  \"\"\"Finds the real Python binary if it\u0027s not a normal absolute path.\"\"\"\n  return FindBinary(module_space, PYTHON_BINARY)\n\ndef PrintVerboseCoverage(*args):\n  \"\"\"Print output if VERBOSE_COVERAGE is non-empty in the environment.\"\"\"\n  if os.environ.get(\"VERBOSE_COVERAGE\"):\n    print(*args, file\u003dsys.stderr)\n\ndef FindCoverageEntryPoint(module_space):\n  cov_tool \u003d \u0027%coverage_tool%\u0027\n  if cov_tool:\n    PrintVerboseCoverage(\u0027Using toolchain coverage_tool %r\u0027 % cov_tool)\n  else:\n    cov_tool \u003d os.environ.get(\u0027PYTHON_COVERAGE\u0027)\n    if cov_tool:\n      PrintVerboseCoverage(\u0027PYTHON_COVERAGE: %r\u0027 % cov_tool)\n  if cov_tool:\n    return FindBinary(module_space, cov_tool)\n  return None\n\ndef FindBinary(module_space, bin_name):\n  \"\"\"Finds the real binary if it\u0027s not a normal absolute path.\"\"\"\n  if not bin_name:\n    return None\n  if bin_name.startswith(\"//\"):\n    # Case 1: Path is a label. Not supported yet.\n    raise AssertionError(\n        \"Bazel does not support execution of Python interpreters via labels yet\"\n    )\n  elif os.path.isabs(bin_name):\n    # Case 2: Absolute path.\n    return bin_name\n  # Use normpath() to convert slashes to os.sep on Windows.\n  elif os.sep in os.path.normpath(bin_name):\n    # Case 3: Path is relative to the repo root.\n    return os.path.join(module_space, bin_name)\n  else:\n    # Case 4: Path has to be looked up in the search path.\n    return SearchPath(bin_name)\n\ndef CreatePythonPathEntries(python_imports, module_space):\n  parts \u003d python_imports.split(\u0027:\u0027)\n  return [module_space] + [\u0027%s/%s\u0027 % (module_space, path) for path in parts]\n\ndef FindModuleSpace(main_rel_path):\n  \"\"\"Finds the runfiles tree.\"\"\"\n  # When the calling process used the runfiles manifest to resolve the\n  # location of this stub script, the path may be expanded. This means\n  # argv[0] may no longer point to a location inside the runfiles\n  # directory. We should therefore respect RUNFILES_DIR and\n  # RUNFILES_MANIFEST_FILE set by the caller.\n  runfiles_dir \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if not runfiles_dir:\n    runfiles_manifest_file \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, \u0027\u0027)\n    if (runfiles_manifest_file.endswith(\u0027.runfiles_manifest\u0027) or\n        runfiles_manifest_file.endswith(\u0027.runfiles/MANIFEST\u0027)):\n      runfiles_dir \u003d runfiles_manifest_file[:-9]\n  # Be defensive: the runfiles dir should contain our main entry point. If\n  # it doesn\u0027t, then it must not be our runfiles directory.\n  if runfiles_dir and os.path.exists(os.path.join(runfiles_dir, main_rel_path)):\n    return runfiles_dir\n\n  stub_filename \u003d sys.argv[0]\n  if not os.path.isabs(stub_filename):\n    stub_filename \u003d os.path.join(os.getcwd(), stub_filename)\n\n  while True:\n    module_space \u003d stub_filename + (\u0027.exe\u0027 if IsWindows() else \u0027\u0027) + \u0027.runfiles\u0027\n    if os.path.isdir(module_space):\n      return module_space\n\n    runfiles_pattern \u003d r\u0027(.*\\.runfiles)\u0027 + (r\u0027\\\\\u0027 if IsWindows() else \u0027/\u0027) + \u0027.*\u0027\n    matchobj \u003d re.match(runfiles_pattern, stub_filename)\n    if matchobj:\n      return matchobj.group(1)\n\n    if not os.path.islink(stub_filename):\n      break\n    target \u003d os.readlink(stub_filename)\n    if os.path.isabs(target):\n      stub_filename \u003d target\n    else:\n      stub_filename \u003d os.path.join(os.path.dirname(stub_filename), target)\n\n  raise AssertionError(\u0027Cannot find .runfiles directory for %s\u0027 % sys.argv[0])\n\ndef ExtractZip(zip_path, dest_dir):\n  \"\"\"Extracts the contents of a zip file, preserving the unix file mode bits.\n\n  These include the permission bits, and in particular, the executable bit.\n\n  Ideally the zipfile module should set these bits, but it doesn\u0027t. See:\n  https://bugs.python.org/issue15795.\n\n  Args:\n      zip_path: The path to the zip file to extract\n      dest_dir: The path to the destination directory\n  \"\"\"\n  zip_path \u003d GetWindowsPathWithUNCPrefix(zip_path)\n  dest_dir \u003d GetWindowsPathWithUNCPrefix(dest_dir)\n  with zipfile.ZipFile(zip_path) as zf:\n    for info in zf.infolist():\n      zf.extract(info, dest_dir)\n      # UNC-prefixed paths must be absolute/normalized. See\n      # https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file#maximum-path-length-limitation\n      file_path \u003d os.path.abspath(os.path.join(dest_dir, info.filename))\n      # The Unix st_mode bits (see \"man 7 inode\") are stored in the upper 16\n      # bits of external_attr. Of those, we set the lower 12 bits, which are the\n      # file mode bits (since the file type bits can\u0027t be set by chmod anyway).\n      attrs \u003d info.external_attr \u003e\u003e 16\n      if attrs !\u003d 0:  # Rumor has it these can be 0 for zips created on Windows.\n        os.chmod(file_path, attrs \u0026 0o7777)\n\n# Create the runfiles tree by extracting the zip file\ndef CreateModuleSpace():\n  temp_dir \u003d tempfile.mkdtemp(\u0027\u0027, \u0027Bazel.runfiles_\u0027)\n  ExtractZip(os.path.dirname(__file__), temp_dir)\n  # IMPORTANT: Later code does `rm -fr` on dirname(module_space) -- it\u0027s\n  # important that deletion code be in sync with this directory structure\n  return os.path.join(temp_dir, \u0027runfiles\u0027)\n\n# Returns repository roots to add to the import path.\ndef GetRepositoriesImports(module_space, import_all):\n  if import_all:\n    repo_dirs \u003d [os.path.join(module_space, d) for d in os.listdir(module_space)]\n    repo_dirs.sort()\n    return [d for d in repo_dirs if os.path.isdir(d)]\n  return [os.path.join(module_space, \u0027%workspace_name%\u0027)]\n\ndef RunfilesEnvvar(module_space):\n  \"\"\"Finds the runfiles manifest or the runfiles directory.\n\n  Returns:\n    A tuple of (var_name, var_value) where var_name is either \u0027RUNFILES_DIR\u0027 or\n    \u0027RUNFILES_MANIFEST_FILE\u0027 and var_value is the path to that directory or\n    file, or (None, None) if runfiles couldn\u0027t be found.\n  \"\"\"\n  # If this binary is the data-dependency of another one, the other sets\n  # RUNFILES_MANIFEST_FILE or RUNFILES_DIR for our sake.\n  runfiles \u003d os.environ.get(\u0027RUNFILES_MANIFEST_FILE\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  runfiles \u003d os.environ.get(\u0027RUNFILES_DIR\u0027, None)\n  if runfiles:\n    return (\u0027RUNFILES_DIR\u0027, runfiles)\n\n  # If running from a zip, there\u0027s no manifest file.\n  if IsRunningFromZip():\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  # Look for the runfiles \"output\" manifest, argv[0] + \".runfiles_manifest\"\n  runfiles \u003d module_space + \u0027_manifest\u0027\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # Look for the runfiles \"input\" manifest, argv[0] + \".runfiles/MANIFEST\"\n  # Normally .runfiles_manifest and MANIFEST are both present, but the\n  # former will be missing for zip-based builds or if someone copies the\n  # runfiles tree elsewhere.\n  runfiles \u003d os.path.join(module_space, \u0027MANIFEST\u0027)\n  if os.path.exists(runfiles):\n    return (\u0027RUNFILES_MANIFEST_FILE\u0027, runfiles)\n\n  # If running in a sandbox and no environment variables are set, then\n  # Look for the runfiles  next to the binary.\n  if module_space.endswith(\u0027.runfiles\u0027) and os.path.isdir(module_space):\n    return (\u0027RUNFILES_DIR\u0027, module_space)\n\n  return (None, None)\n\ndef Deduplicate(items):\n  \"\"\"Efficiently filter out duplicates, keeping the first element only.\"\"\"\n  seen \u003d set()\n  for it in items:\n      if it not in seen:\n          seen.add(it)\n          yield it\n\ndef InstrumentedFilePaths():\n  \"\"\"Yields tuples of realpath of each instrumented file with the relative path.\"\"\"\n  manifest_filename \u003d os.environ.get(\u0027COVERAGE_MANIFEST\u0027)\n  if not manifest_filename:\n    return\n  with open(manifest_filename, \"r\") as manifest:\n    for line in manifest:\n      filename \u003d line.strip()\n      if not filename:\n        continue\n      try:\n        realpath \u003d os.path.realpath(filename)\n      except OSError:\n        print(\n          \"Could not find instrumented file {}\".format(filename),\n          file\u003dsys.stderr)\n        continue\n      if realpath !\u003d filename:\n        PrintVerboseCoverage(\"Fixing up {} -\u003e {}\".format(realpath, filename))\n        yield (realpath, filename)\n\ndef UnresolveSymlinks(output_filename):\n  # type: (str) -\u003e None\n  \"\"\"Replace realpath of instrumented files with the relative path in the lcov output.\n\n  Though we are asking coveragepy to use relative file names, currently\n  ignore that for purposes of generating the lcov report (and other reports\n  which are not the XML report), so we need to go and fix up the report.\n\n  This function is a workaround for that issue. Once that issue is fixed\n  upstream and the updated version is widely in use, this should be removed.\n\n  See https://github.com/nedbat/coveragepy/issues/963.\n  \"\"\"\n  substitutions \u003d list(InstrumentedFilePaths())\n  if substitutions:\n    unfixed_file \u003d output_filename + \u0027.tmp\u0027\n    os.rename(output_filename, unfixed_file)\n    with open(unfixed_file, \"r\") as unfixed:\n      with open(output_filename, \"w\") as output_file:\n        for line in unfixed:\n          if line.startswith(\u0027SF:\u0027):\n            for (realpath, filename) in substitutions:\n              line \u003d line.replace(realpath, filename)\n          output_file.write(line)\n    os.unlink(unfixed_file)\n\ndef ExecuteFile(python_program, main_filename, args, env, module_space,\n                coverage_entrypoint, workspace, delete_module_space):\n  # type: (str, str, list[str], dict[str, str], str, str|None, str|None) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\n\n  This will not return, and acts much like os.execv, except is much\n  more restricted, and handles Bazel-related edge cases.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    module_space: (str) Path to the module space/runfiles tree directory\n    coverage_entrypoint: (str|None) Path to the coverage tool entry point file.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree.\n    delete_module_space: (bool), True if the module space should be deleted\n        after a successful (exit code zero) program run, False if not.\n  \"\"\"\n  # We want to use os.execv instead of subprocess.call, which causes\n  # problems with signal passing (making it difficult to kill\n  # Bazel). However, these conditions force us to run via\n  # subprocess.call instead:\n  #\n  # - On Windows, os.execv doesn\u0027t handle arguments with spaces\n  #   correctly, and it actually starts a subprocess just like\n  #   subprocess.call.\n  # - When running in a workspace or zip file, we need to clean up the\n  #   workspace after the process finishes so control must return here.\n  # - If we may need to emit a host config warning after execution, we\n  #   can\u0027t execv because we need control to return here. This only\n  #   happens for targets built in the host config.\n  # - For coverage targets, at least coveragepy requires running in\n  #   two invocations, which also requires control to return here.\n  #\n  if not (IsWindows() or workspace or coverage_entrypoint or delete_module_space):\n    _RunExecv(python_program, main_filename, args, env)\n\n  if coverage_entrypoint is not None:\n    ret_code \u003d _RunForCoverage(python_program, main_filename, args, env,\n                               coverage_entrypoint, workspace)\n  else:\n    ret_code \u003d subprocess.call(\n      [python_program, main_filename] + args,\n      env\u003denv,\n      cwd\u003dworkspace\n    )\n\n  if delete_module_space:\n    # NOTE: dirname() is called because CreateModuleSpace() creates a\n    # sub-directory within a temporary directory, and we want to remove the\n    # whole temporary directory.\n    shutil.rmtree(os.path.dirname(module_space), True)\n  sys.exit(ret_code)\n\ndef _RunExecv(python_program, main_filename, args, env):\n  # type: (str, str, list[str], dict[str, str]) -\u003e ...\n  \"\"\"Executes the given Python file using the various environment settings.\"\"\"\n  os.environ.update(env)\n  os.execv(python_program, [python_program, main_filename] + args)\n\ndef _RunForCoverage(python_program, main_filename, args, env,\n                    coverage_entrypoint, workspace):\n  # type: (str, str, list[str], dict[str, str], str, str|None) -\u003e int\n  \"\"\"Collects coverage infomration for the given Python file.\n\n  Args:\n    python_program: (str) Path to the Python binary to use for execution\n    main_filename: (str) The Python file to execute\n    args: (list[str]) Additional args to pass to the Python file\n    env: (dict[str, str]) A dict of environment variables to set for the execution\n    coverage_entrypoint: (str|None) Path to the coverage entry point to execute with.\n    workspace: (str|None) Name of the workspace to execute in. This is expected to be a\n        directory under the runfiles tree, and will recursively delete the\n        runfiles directory if set.\n  \"\"\"\n  # We need for coveragepy to use relative paths.  This can only be configured\n  # via an rc file, so we need to make one.\n  rcfile_name \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027.coveragerc\u0027)\n  with open(rcfile_name, \"w\") as rcfile:\n    rcfile.write(\u0027\u0027\u0027[run]\nrelative_files \u003d True\n\u0027\u0027\u0027)\n  PrintVerboseCoverage(\u0027Coverage entrypoint:\u0027, coverage_entrypoint)\n  # First run the target Python file via coveragepy to create a .coverage\n  # database file, from which we can later export lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"run\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"--append\",\n      \"--branch\",\n      main_filename\n    ] + args,\n    env\u003denv,\n    cwd\u003dworkspace\n  )\n  output_filename \u003d os.path.join(os.environ[\u0027COVERAGE_DIR\u0027], \u0027pylcov.dat\u0027)\n\n  PrintVerboseCoverage(\u0027Converting coveragepy database to lcov:\u0027, output_filename)\n  # Run coveragepy again to convert its .coverage database file into lcov.\n  ret_code \u003d subprocess.call(\n    [\n      python_program,\n      coverage_entrypoint,\n      \"lcov\",\n      \"--rcfile\u003d\" + rcfile_name,\n      \"-o\",\n      output_filename\n    ],\n    env\u003denv,\n    cwd\u003dworkspace\n  ) or ret_code\n  try:\n    os.unlink(rcfile_name)\n  except OSError as err:\n    # It\u0027s possible that the profiled program might execute another Python\n    # binary through a wrapper that would then delete the rcfile.  Not much\n    # we can do about that, besides ignore the failure here.\n    PrintVerboseCoverage(\u0027Error removing temporary coverage rc file:\u0027, err)\n  if os.path.isfile(output_filename):\n    UnresolveSymlinks(output_filename)\n  return ret_code\n\ndef Main():\n  args \u003d sys.argv[1:]\n\n  new_env \u003d {}\n\n  # The main Python source file.\n  # The magic string percent-main-percent is replaced with the runfiles-relative\n  # filename of the main file of the Python binary in BazelPythonSemantics.java.\n  main_rel_path \u003d \u0027%main%\u0027\n  if IsWindows():\n    main_rel_path \u003d main_rel_path.replace(\u0027/\u0027, os.sep)\n\n  if IsRunningFromZip():\n    module_space \u003d CreateModuleSpace()\n    delete_module_space \u003d True\n  else:\n    module_space \u003d FindModuleSpace(main_rel_path)\n    delete_module_space \u003d False\n\n  python_imports \u003d \u0027%imports%\u0027\n  python_path_entries \u003d CreatePythonPathEntries(python_imports, module_space)\n  python_path_entries +\u003d GetRepositoriesImports(module_space, %import_all%)\n  # Remove duplicates to avoid overly long PYTHONPATH (#10977). Preserve order,\n  # keep first occurrence only.\n  python_path_entries \u003d [\n    GetWindowsPathWithUNCPrefix(d)\n    for d in python_path_entries\n  ]\n\n  old_python_path \u003d os.environ.get(\u0027PYTHONPATH\u0027)\n  if old_python_path:\n    python_path_entries +\u003d old_python_path.split(os.pathsep)\n\n  python_path \u003d os.pathsep.join(Deduplicate(python_path_entries))\n\n  if IsWindows():\n    python_path \u003d python_path.replace(\u0027/\u0027, os.sep)\n\n  new_env[\u0027PYTHONPATH\u0027] \u003d python_path\n  runfiles_envkey, runfiles_envvalue \u003d RunfilesEnvvar(module_space)\n  if runfiles_envkey:\n    new_env[runfiles_envkey] \u003d runfiles_envvalue\n\n  # Don\u0027t prepend a potentially unsafe path to sys.path\n  # See: https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH\n  new_env[\u0027PYTHONSAFEPATH\u0027] \u003d \u00271\u0027\n\n  main_filename \u003d os.path.join(module_space, main_rel_path)\n  main_filename \u003d GetWindowsPathWithUNCPrefix(main_filename)\n  assert os.path.exists(main_filename), \\\n         \u0027Cannot exec() %r: file not found.\u0027 % main_filename\n  assert os.access(main_filename, os.R_OK), \\\n         \u0027Cannot exec() %r: file not readable.\u0027 % main_filename\n\n  program \u003d python_program \u003d FindPythonBinary(module_space)\n  if python_program is None:\n    raise AssertionError(\u0027Could not find python binary: \u0027 + PYTHON_BINARY)\n\n  # COVERAGE_DIR is set if coverage is enabled and instrumentation is configured\n  # for something, though it could be another program executing this one or\n  # one executed by this one (e.g. an extension module).\n  if os.environ.get(\u0027COVERAGE_DIR\u0027):\n    cov_tool \u003d FindCoverageEntryPoint(module_space)\n    if cov_tool is None:\n      PrintVerboseCoverage(\u0027Coverage was enabled, but python coverage tool was not configured.\u0027)\n    else:\n      # Inhibit infinite recursion:\n      if \u0027PYTHON_COVERAGE\u0027 in os.environ:\n        del os.environ[\u0027PYTHON_COVERAGE\u0027]\n\n      if not os.path.exists(cov_tool):\n        raise EnvironmentError(\n          \u0027Python coverage tool %r not found. \u0027\n          \u0027Try running with VERBOSE_COVERAGE\u003d1 to collect more information.\u0027\n          % cov_tool\n        )\n\n      # coverage library expects sys.path[0] to contain the library, and replaces\n      # it with the directory of the program it starts. Our actual sys.path[0] is\n      # the runfiles directory, which must not be replaced.\n      # CoverageScript.do_execute() undoes this sys.path[0] setting.\n      #\n      # Update sys.path such that python finds the coverage package. The coverage\n      # entry point is coverage.coverage_main, so we need to do twice the dirname.\n      python_path_entries \u003d new_env[\u0027PYTHONPATH\u0027].split(os.pathsep)\n      python_path_entries.append(os.path.dirname(os.path.dirname(cov_tool)))\n      new_env[\u0027PYTHONPATH\u0027] \u003d os.pathsep.join(Deduplicate(python_path_entries))\n  else:\n    cov_tool \u003d None\n\n  new_env.update((key, val) for key, val in os.environ.items() if key not in new_env)\n\n  workspace \u003d None\n  if IsRunningFromZip():\n    # If RUN_UNDER_RUNFILES equals 1, it means we need to\n    # change directory to the right runfiles directory.\n    # (So that the data files are accessible)\n    if os.environ.get(\u0027RUN_UNDER_RUNFILES\u0027) \u003d\u003d \u00271\u0027:\n      workspace \u003d os.path.join(module_space, \u0027%workspace_name%\u0027)\n\n  try:\n    sys.stdout.flush()\n    # NOTE: ExecuteFile may call execve() and lines after this will never run.\n    ExecuteFile(\n      python_program, main_filename, args, new_env, module_space,\n      cov_tool, workspace,\n      delete_module_space \u003d delete_module_space,\n    )\n\n  except EnvironmentError:\n    # This works from Python 2.4 all the way to 3.x.\n    e \u003d sys.exc_info()[1]\n    # This exception occurs when os.execv() fails for some reason.\n    if not getattr(e, \u0027filename\u0027, None):\n      e.filename \u003d program  # Add info to error message\n    raise\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n  Main()\n",
    "substitutions": [{
      "key": "%shebang%",
      "value": "#!/usr/bin/env python3"
    }, {
      "key": "%main%",
      "value": "io_abseil_py/absl/tests/command_name_test.py"
    }, {
      "key": "%python_binary%",
      "value": "bazel_tools/tools/python/py3wrapper.sh"
    }, {
      "key": "%coverage_tool%"
    }, {
      "key": "%imports%"
    }, {
      "key": "%workspace_name%",
      "value": "io_abseil_py"
    }, {
      "key": "%is_zipfile%",
      "value": "True"
    }, {
      "key": "%import_all%",
      "value": "True"
    }, {
      "key": "%target%",
      "value": "//absl:tests/command_name_test"
    }, {
      "key": "%python_version_from_config%",
      "value": "\"3\""
    }, {
      "key": "%python_version_from_attr%",
      "value": "\"3\""
    }, {
      "key": "%python_version_specified_explicitly%",
      "value": "True"
    }]
  }, {
    "targetId": 36,
    "actionKey": "06cf7c70b09ed5288340bd4eec9896c2491c28df7cc35c1b3211e63f44960e02",
    "mnemonic": "PythonZipper",
    "configurationId": 2,
    "inputDepSetIds": [297],
    "outputIds": [430],
    "primaryOutputId": 430,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 36,
    "actionKey": "9dca2fdc7cc4310a66e83d698ab3589f6c667ef475a39355d6553d4734b12b8f",
    "mnemonic": "TestRunner",
    "configurationId": 2,
    "inputDepSetIds": [299],
    "outputIds": [431, 432],
    "primaryOutputId": 431,
    "executionPlatform": "@local_config_platform//:host"
  }, {
    "targetId": 37,
    "actionKey": "655aeb4dd55b9117514abac3731c7cfda9bc04fd4c4be43fa4480238ea5e7f4d",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "inputDepSetIds": [300],
    "outputIds": [434],
    "primaryOutputId": 434,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "ARTIFACT: external/bazel_tools/tools/python/pywrapper_template.txt",
    "substitutions": [{
      "key": "%VERSION%",
      "value": "2"
    }, {
      "key": "%STRICT%",
      "value": "1"
    }]
  }, {
    "targetId": 37,
    "actionKey": "8f868f2f7554dae4c01bb55ff3220e40178651bcf67301a027491dbdd470c326",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "inputDepSetIds": [300],
    "outputIds": [21],
    "primaryOutputId": 21,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "ARTIFACT: external/bazel_tools/tools/python/pywrapper_template.txt",
    "substitutions": [{
      "key": "%VERSION%",
      "value": "3"
    }, {
      "key": "%STRICT%",
      "value": "1"
    }]
  }, {
    "targetId": 37,
    "actionKey": "95b0222542640f8378cca607abc38965df59a7778217eca42122159fc62012a9",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "inputDepSetIds": [300],
    "outputIds": [435],
    "primaryOutputId": 435,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "ARTIFACT: external/bazel_tools/tools/python/pywrapper_template.txt",
    "substitutions": [{
      "key": "%VERSION%",
      "value": "2"
    }, {
      "key": "%STRICT%",
      "value": "0"
    }]
  }, {
    "targetId": 37,
    "actionKey": "419886b344f52b0244eb1a35cb420ede7d5aa3014e95c96ba9135514d3db12f1",
    "mnemonic": "TemplateExpand",
    "configurationId": 1,
    "inputDepSetIds": [300],
    "outputIds": [436],
    "primaryOutputId": 436,
    "executionPlatform": "@local_config_platform//:host",
    "templateContent": "ARTIFACT: external/bazel_tools/tools/python/pywrapper_template.txt",
    "substitutions": [{
      "key": "%VERSION%",
      "value": "3"
    }, {
      "key": "%STRICT%",
      "value": "0"
    }]
  }],
  "targets": [{
    "id": 1,
    "label": "//absl/testing:tests/absltest_fail_fast_test_helper",
    "ruleClassId": 1
  }, {
    "id": 2,
    "label": "//absl/flags:tests/flags_unicode_literals_test",
    "ruleClassId": 2
  }, {
    "id": 3,
    "label": "//absl/flags:tests/argparse_flags_test_helper",
    "ruleClassId": 1
  }, {
    "id": 4,
    "label": "//absl/testing:tests/absltest_randomization_test",
    "ruleClassId": 2
  }, {
    "id": 5,
    "label": "//absl:tests/python_version_test",
    "ruleClassId": 2
  }, {
    "id": 6,
    "label": "//absl/testing:tests/absltest_test_helper",
    "ruleClassId": 1
  }, {
    "id": 7,
    "label": "//absl/testing:tests/absltest_sharding_test",
    "ruleClassId": 2
  }, {
    "id": 8,
    "label": "//absl/testing:tests/absltest_test",
    "ruleClassId": 2
  }, {
    "id": 9,
    "label": "//absl/logging:tests/log_before_import_test",
    "ruleClassId": 2
  }, {
    "id": 10,
    "label": "//absl/testing:tests/absltest_filtering_test_helper",
    "ruleClassId": 1
  }, {
    "id": 11,
    "label": "//absl/flags:tests/flags_test",
    "ruleClassId": 2
  }, {
    "id": 12,
    "label": "//absl/logging:tests/verbosity_flag_test",
    "ruleClassId": 2
  }, {
    "id": 13,
    "label": "//absl/flags:tests/flags_formatting_test",
    "ruleClassId": 2
  }, {
    "id": 14,
    "label": "//absl:tests/app_test_helper_pure_python",
    "ruleClassId": 1
  }, {
    "id": 15,
    "label": "//absl/testing:tests/absltest_fail_fast_test",
    "ruleClassId": 2
  }, {
    "id": 16,
    "label": "//absl/flags:tests/_helpers_test",
    "ruleClassId": 2
  }, {
    "id": 17,
    "label": "//absl/logging:tests/logging_functional_test",
    "ruleClassId": 2
  }, {
    "id": 18,
    "label": "//absl/flags:tests/argparse_flags_test",
    "ruleClassId": 2
  }, {
    "id": 19,
    "label": "//absl/flags:tests/_argument_parser_test",
    "ruleClassId": 2
  }, {
    "id": 20,
    "label": "//absl/flags:tests/_flag_test",
    "ruleClassId": 2
  }, {
    "id": 21,
    "label": "//absl/testing:tests/absltest_sharding_test_helper",
    "ruleClassId": 1
  }, {
    "id": 22,
    "label": "//absl/flags:tests/_flagvalues_test",
    "ruleClassId": 2
  }, {
    "id": 23,
    "label": "//absl/logging:tests/converter_test",
    "ruleClassId": 2
  }, {
    "id": 24,
    "label": "//absl/logging:tests/logging_functional_test_helper",
    "ruleClassId": 1
  }, {
    "id": 25,
    "label": "//absl/testing:tests/xml_reporter_helper_test",
    "ruleClassId": 1
  }, {
    "id": 26,
    "label": "//absl/flags:tests/_validators_test",
    "ruleClassId": 2
  }, {
    "id": 27,
    "label": "//absl/testing:tests/parameterized_test",
    "ruleClassId": 2
  }, {
    "id": 28,
    "label": "//absl/logging:tests/logging_test",
    "ruleClassId": 2
  }, {
    "id": 29,
    "label": "//absl/flags:tests/flags_helpxml_test",
    "ruleClassId": 2
  }, {
    "id": 30,
    "label": "//absl/testing:tests/absltest_randomization_testcase",
    "ruleClassId": 1
  }, {
    "id": 31,
    "label": "//absl/flags:tests/flags_numeric_bounds_test",
    "ruleClassId": 2
  }, {
    "id": 32,
    "label": "//absl/testing:tests/xml_reporter_test",
    "ruleClassId": 2
  }, {
    "id": 33,
    "label": "//absl:tests/app_test",
    "ruleClassId": 2
  }, {
    "id": 34,
    "label": "//absl/testing:tests/flagsaver_test",
    "ruleClassId": 2
  }, {
    "id": 35,
    "label": "//absl/testing:tests/absltest_filtering_test",
    "ruleClassId": 2
  }, {
    "id": 36,
    "label": "//absl:tests/command_name_test",
    "ruleClassId": 2
  }, {
    "id": 37,
    "label": "@bazel_tools//tools/python:_generate_wrappers",
    "ruleClassId": 3
  }],
  "depSetOfFiles": [{
    "id": 1,
    "directArtifactIds": [2]
  }, {
    "id": 5,
    "directArtifactIds": [4, 1]
  }, {
    "id": 7,
    "directArtifactIds": [5, 6]
  }, {
    "id": 10,
    "directArtifactIds": [7, 8]
  }, {
    "id": 12,
    "directArtifactIds": [9, 8]
  }, {
    "id": 13,
    "transitiveDepSetIds": [10, 12],
    "directArtifactIds": [10, 8]
  }, {
    "id": 15,
    "transitiveDepSetIds": [12],
    "directArtifactIds": [11]
  }, {
    "id": 14,
    "transitiveDepSetIds": [12, 13, 15],
    "directArtifactIds": [12, 8]
  }, {
    "id": 16,
    "transitiveDepSetIds": [12, 14, 15],
    "directArtifactIds": [13]
  }, {
    "id": 11,
    "transitiveDepSetIds": [10, 12, 13, 14, 16],
    "directArtifactIds": [14, 8]
  }, {
    "id": 9,
    "transitiveDepSetIds": [10, 11, 12, 13, 14, 16],
    "directArtifactIds": [15, 8]
  }, {
    "id": 17,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [16, 17]
  }, {
    "id": 8,
    "transitiveDepSetIds": [9, 17],
    "directArtifactIds": [18, 19]
  }, {
    "id": 6,
    "transitiveDepSetIds": [7, 8, 9, 17],
    "directArtifactIds": [20, 6]
  }, {
    "id": 4,
    "transitiveDepSetIds": [5, 6, 8],
    "directArtifactIds": [1, 21]
  }, {
    "id": 3,
    "transitiveDepSetIds": [4],
    "directArtifactIds": [21]
  }, {
    "id": 2,
    "transitiveDepSetIds": [3],
    "directArtifactIds": [3]
  }, {
    "id": 19,
    "directArtifactIds": [23, 4, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 18,
    "transitiveDepSetIds": [19],
    "directArtifactIds": [24]
  }, {
    "id": 20,
    "directArtifactIds": [27]
  }, {
    "id": 24,
    "directArtifactIds": [29, 26]
  }, {
    "id": 23,
    "transitiveDepSetIds": [24, 9, 6],
    "directArtifactIds": [26, 21]
  }, {
    "id": 22,
    "transitiveDepSetIds": [23],
    "directArtifactIds": [21]
  }, {
    "id": 21,
    "transitiveDepSetIds": [22],
    "directArtifactIds": [28]
  }, {
    "id": 26,
    "directArtifactIds": [31, 29, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 25,
    "transitiveDepSetIds": [26],
    "directArtifactIds": [24]
  }, {
    "id": 27,
    "directArtifactIds": [30, 33, 34]
  }, {
    "id": 28,
    "directArtifactIds": [38]
  }, {
    "id": 32,
    "directArtifactIds": [40, 37]
  }, {
    "id": 33,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [41]
  }, {
    "id": 31,
    "transitiveDepSetIds": [32, 33, 9, 8],
    "directArtifactIds": [37, 21]
  }, {
    "id": 30,
    "transitiveDepSetIds": [31],
    "directArtifactIds": [21]
  }, {
    "id": 29,
    "transitiveDepSetIds": [30],
    "directArtifactIds": [39]
  }, {
    "id": 35,
    "directArtifactIds": [43, 40, 41, 15, 7, 8, 14, 9, 10, 12, 11, 13, 18, 19, 16, 17, 21]
  }, {
    "id": 34,
    "transitiveDepSetIds": [35],
    "directArtifactIds": [24]
  }, {
    "id": 36,
    "directArtifactIds": [46]
  }, {
    "id": 40,
    "directArtifactIds": [48, 45]
  }, {
    "id": 41,
    "directArtifactIds": [49, 50]
  }, {
    "id": 42,
    "transitiveDepSetIds": [41, 6],
    "directArtifactIds": [50, 21]
  }, {
    "id": 43,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [51]
  }, {
    "id": 44,
    "transitiveDepSetIds": [6],
    "directArtifactIds": [52]
  }, {
    "id": 39,
    "transitiveDepSetIds": [40, 41, 42, 43, 6, 44, 9],
    "directArtifactIds": [53, 45, 21]
  }, {
    "id": 38,
    "transitiveDepSetIds": [39],
    "directArtifactIds": [21]
  }, {
    "id": 37,
    "transitiveDepSetIds": [38],
    "directArtifactIds": [47]
  }, {
    "id": 46,
    "directArtifactIds": [55, 48, 49, 50, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 52, 53]
  }, {
    "id": 45,
    "transitiveDepSetIds": [46],
    "directArtifactIds": [24]
  }, {
    "id": 47,
    "directArtifactIds": [54, 33, 34]
  }, {
    "id": 48,
    "directArtifactIds": [60]
  }, {
    "id": 52,
    "directArtifactIds": [62, 59]
  }, {
    "id": 51,
    "transitiveDepSetIds": [52, 9, 6],
    "directArtifactIds": [59, 21]
  }, {
    "id": 50,
    "transitiveDepSetIds": [51],
    "directArtifactIds": [21]
  }, {
    "id": 49,
    "transitiveDepSetIds": [50],
    "directArtifactIds": [61]
  }, {
    "id": 54,
    "directArtifactIds": [64, 62, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 53,
    "transitiveDepSetIds": [54],
    "directArtifactIds": [24]
  }, {
    "id": 55,
    "directArtifactIds": [63, 33, 34]
  }, {
    "id": 56,
    "directArtifactIds": [69]
  }, {
    "id": 60,
    "directArtifactIds": [71, 68]
  }, {
    "id": 59,
    "transitiveDepSetIds": [60, 6, 8, 9],
    "directArtifactIds": [68, 21]
  }, {
    "id": 58,
    "transitiveDepSetIds": [59],
    "directArtifactIds": [21]
  }, {
    "id": 57,
    "transitiveDepSetIds": [58],
    "directArtifactIds": [70]
  }, {
    "id": 62,
    "directArtifactIds": [73, 71, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 61,
    "transitiveDepSetIds": [62],
    "directArtifactIds": [24]
  }, {
    "id": 63,
    "directArtifactIds": [76]
  }, {
    "id": 67,
    "directArtifactIds": [78, 75]
  }, {
    "id": 68,
    "directArtifactIds": [79, 80]
  }, {
    "id": 69,
    "transitiveDepSetIds": [68, 6],
    "directArtifactIds": [80, 21]
  }, {
    "id": 66,
    "transitiveDepSetIds": [67, 68, 69, 43, 6],
    "directArtifactIds": [53, 75, 21]
  }, {
    "id": 65,
    "transitiveDepSetIds": [66],
    "directArtifactIds": [21]
  }, {
    "id": 64,
    "transitiveDepSetIds": [65],
    "directArtifactIds": [77]
  }, {
    "id": 71,
    "directArtifactIds": [82, 78, 79, 80, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 53]
  }, {
    "id": 70,
    "transitiveDepSetIds": [71],
    "directArtifactIds": [24]
  }, {
    "id": 72,
    "directArtifactIds": [81, 33, 34]
  }, {
    "id": 73,
    "directArtifactIds": [87]
  }, {
    "id": 77,
    "directArtifactIds": [89, 86]
  }, {
    "id": 76,
    "transitiveDepSetIds": [77, 60, 59, 43, 6, 44],
    "directArtifactIds": [53, 86, 21]
  }, {
    "id": 75,
    "transitiveDepSetIds": [76],
    "directArtifactIds": [21]
  }, {
    "id": 74,
    "transitiveDepSetIds": [75],
    "directArtifactIds": [88]
  }, {
    "id": 79,
    "directArtifactIds": [91, 89, 71, 68, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 52, 53]
  }, {
    "id": 78,
    "transitiveDepSetIds": [79],
    "directArtifactIds": [24]
  }, {
    "id": 80,
    "directArtifactIds": [90, 33, 34]
  }, {
    "id": 81,
    "directArtifactIds": [96]
  }, {
    "id": 85,
    "directArtifactIds": [98, 95]
  }, {
    "id": 84,
    "transitiveDepSetIds": [85, 17, 6],
    "directArtifactIds": [95, 21]
  }, {
    "id": 83,
    "transitiveDepSetIds": [84],
    "directArtifactIds": [21]
  }, {
    "id": 82,
    "transitiveDepSetIds": [83],
    "directArtifactIds": [97]
  }, {
    "id": 87,
    "directArtifactIds": [100, 98, 16, 17, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 21]
  }, {
    "id": 86,
    "transitiveDepSetIds": [87],
    "directArtifactIds": [24]
  }, {
    "id": 88,
    "directArtifactIds": [99, 33, 34]
  }, {
    "id": 89,
    "directArtifactIds": [105]
  }, {
    "id": 93,
    "directArtifactIds": [107, 104]
  }, {
    "id": 92,
    "transitiveDepSetIds": [93, 6, 44, 8],
    "directArtifactIds": [104, 21]
  }, {
    "id": 91,
    "transitiveDepSetIds": [92],
    "directArtifactIds": [21]
  }, {
    "id": 90,
    "transitiveDepSetIds": [91],
    "directArtifactIds": [106]
  }, {
    "id": 95,
    "directArtifactIds": [109, 107, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 52, 21]
  }, {
    "id": 94,
    "transitiveDepSetIds": [95],
    "directArtifactIds": [24]
  }, {
    "id": 96,
    "directArtifactIds": [112]
  }, {
    "id": 100,
    "directArtifactIds": [114, 111]
  }, {
    "id": 101,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [115, 8]
  }, {
    "id": 102,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [116]
  }, {
    "id": 103,
    "transitiveDepSetIds": [9, 101],
    "directArtifactIds": [117, 8]
  }, {
    "id": 99,
    "transitiveDepSetIds": [100, 12, 9, 101, 102, 103, 6],
    "directArtifactIds": [8, 111, 21]
  }, {
    "id": 98,
    "transitiveDepSetIds": [99],
    "directArtifactIds": [21]
  }, {
    "id": 97,
    "transitiveDepSetIds": [98],
    "directArtifactIds": [113]
  }, {
    "id": 105,
    "directArtifactIds": [119, 114, 9, 8, 15, 7, 14, 10, 12, 11, 13, 115, 116, 117, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 104,
    "transitiveDepSetIds": [105],
    "directArtifactIds": [24]
  }, {
    "id": 106,
    "directArtifactIds": [118, 33, 34]
  }, {
    "id": 107,
    "directArtifactIds": [124]
  }, {
    "id": 111,
    "directArtifactIds": [126, 123]
  }, {
    "id": 110,
    "transitiveDepSetIds": [111, 17, 9, 6],
    "directArtifactIds": [123, 21]
  }, {
    "id": 109,
    "transitiveDepSetIds": [110],
    "directArtifactIds": [21]
  }, {
    "id": 108,
    "transitiveDepSetIds": [109],
    "directArtifactIds": [125]
  }, {
    "id": 113,
    "directArtifactIds": [128, 126, 16, 17, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 21]
  }, {
    "id": 112,
    "transitiveDepSetIds": [113],
    "directArtifactIds": [24]
  }, {
    "id": 114,
    "directArtifactIds": [127, 33, 34]
  }, {
    "id": 115,
    "directArtifactIds": [133]
  }, {
    "id": 119,
    "directArtifactIds": [135, 132]
  }, {
    "id": 118,
    "transitiveDepSetIds": [119, 9, 6],
    "directArtifactIds": [8, 132, 21]
  }, {
    "id": 117,
    "transitiveDepSetIds": [118],
    "directArtifactIds": [21]
  }, {
    "id": 116,
    "transitiveDepSetIds": [117],
    "directArtifactIds": [134]
  }, {
    "id": 121,
    "directArtifactIds": [137, 135, 8, 15, 7, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 120,
    "transitiveDepSetIds": [121],
    "directArtifactIds": [24]
  }, {
    "id": 122,
    "directArtifactIds": [136, 33, 34]
  }, {
    "id": 123,
    "directArtifactIds": [142]
  }, {
    "id": 127,
    "directArtifactIds": [144, 141]
  }, {
    "id": 126,
    "transitiveDepSetIds": [127, 8, 9],
    "directArtifactIds": [141, 21]
  }, {
    "id": 125,
    "transitiveDepSetIds": [126],
    "directArtifactIds": [21]
  }, {
    "id": 124,
    "transitiveDepSetIds": [125],
    "directArtifactIds": [143]
  }, {
    "id": 129,
    "directArtifactIds": [146, 144, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 128,
    "transitiveDepSetIds": [129],
    "directArtifactIds": [24]
  }, {
    "id": 130,
    "directArtifactIds": [149]
  }, {
    "id": 134,
    "directArtifactIds": [151, 148]
  }, {
    "id": 133,
    "transitiveDepSetIds": [134, 5, 4, 43, 6, 44, 17],
    "directArtifactIds": [53, 148, 21]
  }, {
    "id": 132,
    "transitiveDepSetIds": [133],
    "directArtifactIds": [21]
  }, {
    "id": 131,
    "transitiveDepSetIds": [132],
    "directArtifactIds": [150]
  }, {
    "id": 136,
    "directArtifactIds": [153, 151, 4, 1, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 52, 53]
  }, {
    "id": 135,
    "transitiveDepSetIds": [136],
    "directArtifactIds": [24]
  }, {
    "id": 137,
    "directArtifactIds": [152, 33, 34]
  }, {
    "id": 138,
    "directArtifactIds": [158]
  }, {
    "id": 142,
    "directArtifactIds": [160, 157]
  }, {
    "id": 141,
    "transitiveDepSetIds": [142, 101, 103, 6],
    "directArtifactIds": [8, 157, 21]
  }, {
    "id": 140,
    "transitiveDepSetIds": [141],
    "directArtifactIds": [21]
  }, {
    "id": 139,
    "transitiveDepSetIds": [140],
    "directArtifactIds": [159]
  }, {
    "id": 144,
    "directArtifactIds": [162, 160, 8, 115, 15, 7, 14, 9, 10, 12, 11, 13, 117, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 143,
    "transitiveDepSetIds": [144],
    "directArtifactIds": [24]
  }, {
    "id": 145,
    "directArtifactIds": [161, 33, 34]
  }, {
    "id": 146,
    "directArtifactIds": [167]
  }, {
    "id": 150,
    "directArtifactIds": [169, 166]
  }, {
    "id": 151,
    "directArtifactIds": [170, 171]
  }, {
    "id": 152,
    "transitiveDepSetIds": [151, 17, 8, 9],
    "directArtifactIds": [171, 21]
  }, {
    "id": 149,
    "transitiveDepSetIds": [150, 151, 152, 17, 43, 6, 44],
    "directArtifactIds": [166, 21]
  }, {
    "id": 148,
    "transitiveDepSetIds": [149],
    "directArtifactIds": [21]
  }, {
    "id": 147,
    "transitiveDepSetIds": [148],
    "directArtifactIds": [168]
  }, {
    "id": 154,
    "directArtifactIds": [173, 169, 170, 171, 16, 17, 15, 7, 8, 14, 9, 10, 12, 11, 13, 18, 19, 21, 51, 20, 6, 5, 52]
  }, {
    "id": 153,
    "transitiveDepSetIds": [154],
    "directArtifactIds": [24]
  }, {
    "id": 155,
    "directArtifactIds": [172, 33, 34]
  }, {
    "id": 156,
    "directArtifactIds": [276]
  }, {
    "id": 160,
    "directArtifactIds": [278, 275]
  }, {
    "id": 159,
    "transitiveDepSetIds": [160, 32, 31, 33, 9, 17, 43, 6, 44],
    "directArtifactIds": [275, 21]
  }, {
    "id": 158,
    "transitiveDepSetIds": [159],
    "directArtifactIds": [21]
  }, {
    "id": 157,
    "transitiveDepSetIds": [158],
    "directArtifactIds": [277]
  }, {
    "id": 162,
    "directArtifactIds": [280, 278, 40, 37, 41, 15, 7, 8, 14, 9, 10, 12, 11, 13, 18, 19, 16, 17, 21, 51, 20, 6, 5, 52]
  }, {
    "id": 161,
    "transitiveDepSetIds": [162],
    "directArtifactIds": [24]
  }, {
    "id": 163,
    "directArtifactIds": [279, 33, 34]
  }, {
    "id": 164,
    "directArtifactIds": [285]
  }, {
    "id": 168,
    "directArtifactIds": [287, 284]
  }, {
    "id": 167,
    "transitiveDepSetIds": [168, 10, 6, 44],
    "directArtifactIds": [284, 21]
  }, {
    "id": 166,
    "transitiveDepSetIds": [167],
    "directArtifactIds": [21]
  }, {
    "id": 165,
    "transitiveDepSetIds": [166],
    "directArtifactIds": [286]
  }, {
    "id": 170,
    "directArtifactIds": [289, 287, 7, 8, 20, 6, 5, 18, 19, 15, 14, 9, 10, 12, 11, 13, 16, 17, 52, 21]
  }, {
    "id": 169,
    "transitiveDepSetIds": [170],
    "directArtifactIds": [24]
  }, {
    "id": 171,
    "directArtifactIds": [288, 33, 34]
  }, {
    "id": 172,
    "directArtifactIds": [294]
  }, {
    "id": 176,
    "directArtifactIds": [296, 293]
  }, {
    "id": 175,
    "transitiveDepSetIds": [176, 10, 12, 13, 6, 44],
    "directArtifactIds": [293, 21]
  }, {
    "id": 174,
    "transitiveDepSetIds": [175],
    "directArtifactIds": [21]
  }, {
    "id": 173,
    "transitiveDepSetIds": [174],
    "directArtifactIds": [295]
  }, {
    "id": 178,
    "directArtifactIds": [298, 296, 7, 8, 9, 10, 20, 6, 5, 18, 19, 15, 14, 12, 11, 13, 16, 17, 52, 21]
  }, {
    "id": 177,
    "transitiveDepSetIds": [178],
    "directArtifactIds": [24]
  }, {
    "id": 179,
    "directArtifactIds": [297, 33, 34]
  }, {
    "id": 180,
    "directArtifactIds": [302]
  }, {
    "id": 182,
    "transitiveDepSetIds": [69],
    "directArtifactIds": [21]
  }, {
    "id": 181,
    "transitiveDepSetIds": [182],
    "directArtifactIds": [303]
  }, {
    "id": 184,
    "directArtifactIds": [305, 79, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 183,
    "transitiveDepSetIds": [184],
    "directArtifactIds": [24]
  }, {
    "id": 185,
    "directArtifactIds": [308]
  }, {
    "id": 189,
    "directArtifactIds": [310, 307]
  }, {
    "id": 188,
    "transitiveDepSetIds": [189, 11, 12, 14, 16, 103, 17, 6, 44],
    "directArtifactIds": [8, 307, 21]
  }, {
    "id": 187,
    "transitiveDepSetIds": [188],
    "directArtifactIds": [21]
  }, {
    "id": 186,
    "transitiveDepSetIds": [187],
    "directArtifactIds": [309]
  }, {
    "id": 191,
    "directArtifactIds": [312, 310, 14, 7, 8, 9, 10, 12, 11, 13, 117, 15, 115, 16, 17, 20, 6, 5, 18, 19, 52, 21]
  }, {
    "id": 190,
    "transitiveDepSetIds": [191],
    "directArtifactIds": [24]
  }, {
    "id": 192,
    "directArtifactIds": [311, 33, 34]
  }, {
    "id": 193,
    "directArtifactIds": [317]
  }, {
    "id": 197,
    "directArtifactIds": [319, 316]
  }, {
    "id": 196,
    "transitiveDepSetIds": [197, 17, 6],
    "directArtifactIds": [17, 316, 21]
  }, {
    "id": 195,
    "transitiveDepSetIds": [196],
    "directArtifactIds": [21]
  }, {
    "id": 194,
    "transitiveDepSetIds": [195],
    "directArtifactIds": [318]
  }, {
    "id": 199,
    "directArtifactIds": [321, 319, 17, 16, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 21]
  }, {
    "id": 198,
    "transitiveDepSetIds": [199],
    "directArtifactIds": [24]
  }, {
    "id": 200,
    "directArtifactIds": [320, 33, 34]
  }, {
    "id": 201,
    "directArtifactIds": [325]
  }, {
    "id": 203,
    "transitiveDepSetIds": [152],
    "directArtifactIds": [21]
  }, {
    "id": 202,
    "transitiveDepSetIds": [203],
    "directArtifactIds": [326]
  }, {
    "id": 205,
    "directArtifactIds": [328, 170, 16, 17, 15, 7, 8, 14, 9, 10, 12, 11, 13, 18, 19, 21]
  }, {
    "id": 204,
    "transitiveDepSetIds": [205],
    "directArtifactIds": [24]
  }, {
    "id": 206,
    "directArtifactIds": [331]
  }, {
    "id": 210,
    "directArtifactIds": [333, 330]
  }, {
    "id": 209,
    "transitiveDepSetIds": [210, 6, 9],
    "directArtifactIds": [330, 21]
  }, {
    "id": 208,
    "transitiveDepSetIds": [209],
    "directArtifactIds": [21]
  }, {
    "id": 207,
    "transitiveDepSetIds": [208],
    "directArtifactIds": [332]
  }, {
    "id": 212,
    "directArtifactIds": [335, 333, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 211,
    "transitiveDepSetIds": [212],
    "directArtifactIds": [24]
  }, {
    "id": 213,
    "directArtifactIds": [338]
  }, {
    "id": 217,
    "directArtifactIds": [340, 337]
  }, {
    "id": 216,
    "transitiveDepSetIds": [217, 11, 12, 14, 16, 6],
    "directArtifactIds": [337, 21]
  }, {
    "id": 215,
    "transitiveDepSetIds": [216],
    "directArtifactIds": [21]
  }, {
    "id": 214,
    "transitiveDepSetIds": [215],
    "directArtifactIds": [339]
  }, {
    "id": 219,
    "directArtifactIds": [342, 340, 14, 7, 8, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 15, 16, 17, 21]
  }, {
    "id": 218,
    "transitiveDepSetIds": [219],
    "directArtifactIds": [24]
  }, {
    "id": 220,
    "directArtifactIds": [341, 33, 34]
  }, {
    "id": 221,
    "directArtifactIds": [347]
  }, {
    "id": 225,
    "directArtifactIds": [349, 346]
  }, {
    "id": 224,
    "transitiveDepSetIds": [225, 6, 44],
    "directArtifactIds": [346, 21]
  }, {
    "id": 223,
    "transitiveDepSetIds": [224],
    "directArtifactIds": [21]
  }, {
    "id": 222,
    "transitiveDepSetIds": [223],
    "directArtifactIds": [348]
  }, {
    "id": 227,
    "directArtifactIds": [351, 349, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 52, 21]
  }, {
    "id": 226,
    "transitiveDepSetIds": [227],
    "directArtifactIds": [24]
  }, {
    "id": 228,
    "directArtifactIds": [350, 33, 34]
  }, {
    "id": 229,
    "directArtifactIds": [356]
  }, {
    "id": 233,
    "directArtifactIds": [358, 355]
  }, {
    "id": 234,
    "transitiveDepSetIds": [9],
    "directArtifactIds": [359]
  }, {
    "id": 232,
    "transitiveDepSetIds": [233, 17, 9, 6, 234, 44],
    "directArtifactIds": [355, 21]
  }, {
    "id": 231,
    "transitiveDepSetIds": [232],
    "directArtifactIds": [21]
  }, {
    "id": 230,
    "transitiveDepSetIds": [231],
    "directArtifactIds": [357]
  }, {
    "id": 236,
    "directArtifactIds": [361, 358, 16, 17, 15, 7, 8, 14, 9, 10, 12, 11, 13, 20, 6, 5, 18, 19, 359, 52, 21]
  }, {
    "id": 235,
    "transitiveDepSetIds": [236],
    "directArtifactIds": [24]
  }, {
    "id": 237,
    "directArtifactIds": [360, 33, 34]
  }, {
    "id": 238,
    "directArtifactIds": [366]
  }, {
    "id": 242,
    "directArtifactIds": [368, 365]
  }, {
    "id": 241,
    "transitiveDepSetIds": [242, 9, 101, 6],
    "directArtifactIds": [8, 365, 21]
  }, {
    "id": 240,
    "transitiveDepSetIds": [241],
    "directArtifactIds": [21]
  }, {
    "id": 239,
    "transitiveDepSetIds": [240],
    "directArtifactIds": [367]
  }, {
    "id": 244,
    "directArtifactIds": [370, 368, 8, 15, 7, 14, 9, 10, 12, 11, 13, 115, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 243,
    "transitiveDepSetIds": [244],
    "directArtifactIds": [24]
  }, {
    "id": 245,
    "directArtifactIds": [369, 33, 34]
  }, {
    "id": 246,
    "directArtifactIds": [374]
  }, {
    "id": 248,
    "transitiveDepSetIds": [42],
    "directArtifactIds": [21]
  }, {
    "id": 247,
    "transitiveDepSetIds": [248],
    "directArtifactIds": [375]
  }, {
    "id": 250,
    "directArtifactIds": [377, 49, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 249,
    "transitiveDepSetIds": [250],
    "directArtifactIds": [24]
  }, {
    "id": 251,
    "directArtifactIds": [380]
  }, {
    "id": 255,
    "directArtifactIds": [382, 379]
  }, {
    "id": 254,
    "transitiveDepSetIds": [255, 16, 9, 6],
    "directArtifactIds": [379, 21]
  }, {
    "id": 253,
    "transitiveDepSetIds": [254],
    "directArtifactIds": [21]
  }, {
    "id": 252,
    "transitiveDepSetIds": [253],
    "directArtifactIds": [381]
  }, {
    "id": 257,
    "directArtifactIds": [384, 382, 13, 9, 8, 12, 10, 7, 11, 15, 14, 20, 6, 5, 18, 19, 16, 17, 21]
  }, {
    "id": 256,
    "transitiveDepSetIds": [257],
    "directArtifactIds": [24]
  }, {
    "id": 258,
    "directArtifactIds": [383, 33, 34]
  }, {
    "id": 259,
    "directArtifactIds": [389]
  }, {
    "id": 263,
    "directArtifactIds": [391, 388]
  }, {
    "id": 262,
    "transitiveDepSetIds": [263, 210, 209, 43, 6, 44, 7, 17],
    "directArtifactIds": [388, 21]
  }, {
    "id": 261,
    "transitiveDepSetIds": [262],
    "directArtifactIds": [21]
  }, {
    "id": 260,
    "transitiveDepSetIds": [261],
    "directArtifactIds": [390]
  }, {
    "id": 265,
    "directArtifactIds": [393, 391, 333, 330, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 52]
  }, {
    "id": 264,
    "transitiveDepSetIds": [265],
    "directArtifactIds": [24]
  }, {
    "id": 266,
    "directArtifactIds": [392, 33, 34]
  }, {
    "id": 267,
    "directArtifactIds": [398]
  }, {
    "id": 271,
    "directArtifactIds": [400, 397]
  }, {
    "id": 272,
    "transitiveDepSetIds": [8, 9],
    "directArtifactIds": [144]
  }, {
    "id": 270,
    "transitiveDepSetIds": [271, 127, 126, 8, 272, 9, 43, 6, 234],
    "directArtifactIds": [397, 21]
  }, {
    "id": 269,
    "transitiveDepSetIds": [270],
    "directArtifactIds": [21]
  }, {
    "id": 268,
    "transitiveDepSetIds": [269],
    "directArtifactIds": [399]
  }, {
    "id": 274,
    "directArtifactIds": [402, 400, 144, 141, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21, 51, 20, 6, 5, 359]
  }, {
    "id": 273,
    "transitiveDepSetIds": [274],
    "directArtifactIds": [24]
  }, {
    "id": 275,
    "directArtifactIds": [401, 33, 34]
  }, {
    "id": 276,
    "directArtifactIds": [407]
  }, {
    "id": 280,
    "directArtifactIds": [409, 406]
  }, {
    "id": 279,
    "transitiveDepSetIds": [280, 6, 234, 44, 9],
    "directArtifactIds": [406, 21]
  }, {
    "id": 278,
    "transitiveDepSetIds": [279],
    "directArtifactIds": [21]
  }, {
    "id": 277,
    "transitiveDepSetIds": [278],
    "directArtifactIds": [408]
  }, {
    "id": 282,
    "directArtifactIds": [411, 409, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 359, 52, 21]
  }, {
    "id": 281,
    "transitiveDepSetIds": [282],
    "directArtifactIds": [24]
  }, {
    "id": 283,
    "directArtifactIds": [410, 33, 34]
  }, {
    "id": 284,
    "directArtifactIds": [416]
  }, {
    "id": 288,
    "directArtifactIds": [418, 415]
  }, {
    "id": 287,
    "transitiveDepSetIds": [288, 93, 92, 43, 6, 44, 17],
    "directArtifactIds": [53, 415, 21]
  }, {
    "id": 286,
    "transitiveDepSetIds": [287],
    "directArtifactIds": [21]
  }, {
    "id": 285,
    "transitiveDepSetIds": [286],
    "directArtifactIds": [417]
  }, {
    "id": 290,
    "directArtifactIds": [420, 418, 107, 104, 20, 6, 5, 18, 19, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 52, 21, 51, 53]
  }, {
    "id": 289,
    "transitiveDepSetIds": [290],
    "directArtifactIds": [24]
  }, {
    "id": 291,
    "directArtifactIds": [419, 33, 34]
  }, {
    "id": 292,
    "directArtifactIds": [425]
  }, {
    "id": 296,
    "directArtifactIds": [427, 424]
  }, {
    "id": 295,
    "transitiveDepSetIds": [296, 6],
    "directArtifactIds": [19, 424, 21]
  }, {
    "id": 294,
    "transitiveDepSetIds": [295],
    "directArtifactIds": [21]
  }, {
    "id": 293,
    "transitiveDepSetIds": [294],
    "directArtifactIds": [426]
  }, {
    "id": 298,
    "directArtifactIds": [429, 427, 19, 20, 6, 5, 18, 15, 7, 8, 14, 9, 10, 12, 11, 13, 16, 17, 21]
  }, {
    "id": 297,
    "transitiveDepSetIds": [298],
    "directArtifactIds": [24]
  }, {
    "id": 299,
    "directArtifactIds": [428, 33, 34]
  }, {
    "id": 300,
    "directArtifactIds": [433]
  }],
  "configuration": [{
    "id": 1,
    "mnemonic": "k8-fastbuild",
    "platformName": "k8",
    "checksum": "4e67ca85ce50afa1c60118c9ac5cb28f1e0a8fe7c49020037cc89ebbb414d9ff"
  }, {
    "id": 2,
    "mnemonic": "k8-fastbuild",
    "platformName": "k8",
    "checksum": "6953f50a4ed022a2378305ea5b0bdb7d6e9ee5908a343a30208648fc7160feea"
  }],
  "ruleClasses": [{
    "id": 1,
    "name": "py_binary"
  }, {
    "id": 2,
    "name": "py_test"
  }, {
    "id": 3,
    "name": "expand_pyversion_template"
  }],
  "pathFragments": [{
    "id": 7,
    "label": "bazel-out"
  }, {
    "id": 6,
    "label": "k8-fastbuild",
    "parentId": 7
  }, {
    "id": 5,
    "label": "bin",
    "parentId": 6
  }, {
    "id": 4,
    "label": "absl",
    "parentId": 5
  }, {
    "id": 3,
    "label": "testing",
    "parentId": 4
  }, {
    "id": 2,
    "label": "tests",
    "parentId": 3
  }, {
    "id": 1,
    "label": "absltest_fail_fast_test_helper",
    "parentId": 2
  }, {
    "id": 8,
    "label": "absltest_fail_fast_test_helper.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 10,
    "label": "absltest_fail_fast_test_helper.runfiles",
    "parentId": 2
  }, {
    "id": 9,
    "label": "MANIFEST",
    "parentId": 10
  }, {
    "id": 14,
    "label": "absl"
  }, {
    "id": 13,
    "label": "testing",
    "parentId": 14
  }, {
    "id": 12,
    "label": "tests",
    "parentId": 13
  }, {
    "id": 11,
    "label": "absltest_fail_fast_test_helper.py",
    "parentId": 12
  }, {
    "id": 15,
    "label": "xml_reporter.py",
    "parentId": 13
  }, {
    "id": 16,
    "label": "_pretty_print_reporter.py",
    "parentId": 13
  }, {
    "id": 18,
    "label": "flags",
    "parentId": 14
  }, {
    "id": 17,
    "label": "_argument_parser.py",
    "parentId": 18
  }, {
    "id": 19,
    "label": "_helpers.py",
    "parentId": 18
  }, {
    "id": 20,
    "label": "_exceptions.py",
    "parentId": 18
  }, {
    "id": 21,
    "label": "_flag.py",
    "parentId": 18
  }, {
    "id": 22,
    "label": "_validators_classes.py",
    "parentId": 18
  }, {
    "id": 23,
    "label": "_flagvalues.py",
    "parentId": 18
  }, {
    "id": 24,
    "label": "_validators.py",
    "parentId": 18
  }, {
    "id": 25,
    "label": "_defines.py",
    "parentId": 18
  }, {
    "id": 26,
    "label": "__init__.py",
    "parentId": 18
  }, {
    "id": 28,
    "label": "logging",
    "parentId": 14
  }, {
    "id": 27,
    "label": "__init__.py",
    "parentId": 28
  }, {
    "id": 29,
    "label": "converter.py",
    "parentId": 28
  }, {
    "id": 30,
    "label": "app.py",
    "parentId": 14
  }, {
    "id": 31,
    "label": "command_name.py",
    "parentId": 14
  }, {
    "id": 32,
    "label": "absltest.py",
    "parentId": 13
  }, {
    "id": 37,
    "label": "external",
    "parentId": 5
  }, {
    "id": 36,
    "label": "bazel_tools",
    "parentId": 37
  }, {
    "id": 35,
    "label": "tools",
    "parentId": 36
  }, {
    "id": 34,
    "label": "python",
    "parentId": 35
  }, {
    "id": 33,
    "label": "py3wrapper.sh",
    "parentId": 34
  }, {
    "id": 40,
    "label": "internal",
    "parentId": 6
  }, {
    "id": 39,
    "label": "_middlemen",
    "parentId": 40
  }, {
    "id": 38,
    "label": "absl_Stesting_Stests_Sabsltest_Ufail_Ufast_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 41,
    "label": "absltest_fail_fast_test_helper.temp",
    "parentId": 2
  }, {
    "id": 47,
    "label": "external"
  }, {
    "id": 46,
    "label": "bazel_tools",
    "parentId": 47
  }, {
    "id": 45,
    "label": "tools",
    "parentId": 46
  }, {
    "id": 44,
    "label": "zip",
    "parentId": 45
  }, {
    "id": 43,
    "label": "zipper",
    "parentId": 44
  }, {
    "id": 42,
    "label": "zipper",
    "parentId": 43
  }, {
    "id": 48,
    "label": "absltest_fail_fast_test_helper.zip",
    "parentId": 2
  }, {
    "id": 51,
    "label": "flags",
    "parentId": 4
  }, {
    "id": 50,
    "label": "tests",
    "parentId": 51
  }, {
    "id": 49,
    "label": "flags_unicode_literals_test",
    "parentId": 50
  }, {
    "id": 52,
    "label": "flags_unicode_literals_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 54,
    "label": "flags_unicode_literals_test.runfiles",
    "parentId": 50
  }, {
    "id": 53,
    "label": "MANIFEST",
    "parentId": 54
  }, {
    "id": 56,
    "label": "tests",
    "parentId": 18
  }, {
    "id": 55,
    "label": "flags_unicode_literals_test.py",
    "parentId": 56
  }, {
    "id": 57,
    "label": "absl_Sflags_Stests_Sflags_Uunicode_Uliterals_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 58,
    "label": "flags_unicode_literals_test.temp",
    "parentId": 50
  }, {
    "id": 59,
    "label": "flags_unicode_literals_test.zip",
    "parentId": 50
  }, {
    "id": 61,
    "label": "test",
    "parentId": 45
  }, {
    "id": 60,
    "label": "test-setup.sh",
    "parentId": 61
  }, {
    "id": 62,
    "label": "generate-xml.sh",
    "parentId": 61
  }, {
    "id": 68,
    "label": "testlogs",
    "parentId": 6
  }, {
    "id": 67,
    "label": "absl",
    "parentId": 68
  }, {
    "id": 66,
    "label": "flags",
    "parentId": 67
  }, {
    "id": 65,
    "label": "tests",
    "parentId": 66
  }, {
    "id": 64,
    "label": "flags_unicode_literals_test",
    "parentId": 65
  }, {
    "id": 63,
    "label": "test.log",
    "parentId": 64
  }, {
    "id": 69,
    "label": "test.cache_status",
    "parentId": 64
  }, {
    "id": 70,
    "label": "argparse_flags_test_helper",
    "parentId": 50
  }, {
    "id": 71,
    "label": "argparse_flags_test_helper.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 73,
    "label": "argparse_flags_test_helper.runfiles",
    "parentId": 50
  }, {
    "id": 72,
    "label": "MANIFEST",
    "parentId": 73
  }, {
    "id": 74,
    "label": "argparse_flags_test_helper.py",
    "parentId": 56
  }, {
    "id": 75,
    "label": "argparse_flags.py",
    "parentId": 18
  }, {
    "id": 76,
    "label": "absl_Sflags_Stests_Sargparse_Uflags_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 77,
    "label": "argparse_flags_test_helper.temp",
    "parentId": 50
  }, {
    "id": 78,
    "label": "argparse_flags_test_helper.zip",
    "parentId": 50
  }, {
    "id": 79,
    "label": "absltest_randomization_test",
    "parentId": 2
  }, {
    "id": 80,
    "label": "absltest_randomization_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 82,
    "label": "absltest_randomization_test.runfiles",
    "parentId": 2
  }, {
    "id": 81,
    "label": "MANIFEST",
    "parentId": 82
  }, {
    "id": 83,
    "label": "absltest_randomization_test.py",
    "parentId": 12
  }, {
    "id": 84,
    "label": "absltest_randomization_testcase.py",
    "parentId": 12
  }, {
    "id": 85,
    "label": "absltest_randomization_testcase",
    "parentId": 2
  }, {
    "id": 86,
    "label": "_bazelize_command.py",
    "parentId": 13
  }, {
    "id": 87,
    "label": "parameterized.py",
    "parentId": 13
  }, {
    "id": 88,
    "label": "absltest_env.py",
    "parentId": 12
  }, {
    "id": 89,
    "label": "absl_Stesting_Stests_Sabsltest_Urandomization_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 90,
    "label": "absltest_randomization_test.temp",
    "parentId": 2
  }, {
    "id": 91,
    "label": "absltest_randomization_test.zip",
    "parentId": 2
  }, {
    "id": 95,
    "label": "testing",
    "parentId": 67
  }, {
    "id": 94,
    "label": "tests",
    "parentId": 95
  }, {
    "id": 93,
    "label": "absltest_randomization_test",
    "parentId": 94
  }, {
    "id": 92,
    "label": "test.log",
    "parentId": 93
  }, {
    "id": 96,
    "label": "test.cache_status",
    "parentId": 93
  }, {
    "id": 98,
    "label": "tests",
    "parentId": 4
  }, {
    "id": 97,
    "label": "python_version_test",
    "parentId": 98
  }, {
    "id": 99,
    "label": "python_version_test.runfiles_manifest",
    "parentId": 98
  }, {
    "id": 101,
    "label": "python_version_test.runfiles",
    "parentId": 98
  }, {
    "id": 100,
    "label": "MANIFEST",
    "parentId": 101
  }, {
    "id": 103,
    "label": "tests",
    "parentId": 14
  }, {
    "id": 102,
    "label": "python_version_test.py",
    "parentId": 103
  }, {
    "id": 104,
    "label": "absl_Stests_Spython_Uversion_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 105,
    "label": "python_version_test.temp",
    "parentId": 98
  }, {
    "id": 106,
    "label": "python_version_test.zip",
    "parentId": 98
  }, {
    "id": 109,
    "label": "tests",
    "parentId": 67
  }, {
    "id": 108,
    "label": "python_version_test",
    "parentId": 109
  }, {
    "id": 107,
    "label": "test.log",
    "parentId": 108
  }, {
    "id": 110,
    "label": "test.cache_status",
    "parentId": 108
  }, {
    "id": 111,
    "label": "absltest_test_helper",
    "parentId": 2
  }, {
    "id": 112,
    "label": "absltest_test_helper.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 114,
    "label": "absltest_test_helper.runfiles",
    "parentId": 2
  }, {
    "id": 113,
    "label": "MANIFEST",
    "parentId": 114
  }, {
    "id": 115,
    "label": "absltest_test_helper.py",
    "parentId": 12
  }, {
    "id": 116,
    "label": "absl_Stesting_Stests_Sabsltest_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 117,
    "label": "absltest_test_helper.temp",
    "parentId": 2
  }, {
    "id": 118,
    "label": "absltest_test_helper.zip",
    "parentId": 2
  }, {
    "id": 119,
    "label": "absltest_sharding_test",
    "parentId": 2
  }, {
    "id": 120,
    "label": "absltest_sharding_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 122,
    "label": "absltest_sharding_test.runfiles",
    "parentId": 2
  }, {
    "id": 121,
    "label": "MANIFEST",
    "parentId": 122
  }, {
    "id": 123,
    "label": "absltest_sharding_test.py",
    "parentId": 12
  }, {
    "id": 124,
    "label": "absltest_sharding_test_helper.py",
    "parentId": 12
  }, {
    "id": 125,
    "label": "absltest_sharding_test_helper",
    "parentId": 2
  }, {
    "id": 126,
    "label": "absl_Stesting_Stests_Sabsltest_Usharding_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 127,
    "label": "absltest_sharding_test.temp",
    "parentId": 2
  }, {
    "id": 128,
    "label": "absltest_sharding_test.zip",
    "parentId": 2
  }, {
    "id": 130,
    "label": "absltest_sharding_test",
    "parentId": 94
  }, {
    "id": 129,
    "label": "test.log",
    "parentId": 130
  }, {
    "id": 131,
    "label": "test.cache_status",
    "parentId": 130
  }, {
    "id": 132,
    "label": "absltest_test",
    "parentId": 2
  }, {
    "id": 133,
    "label": "absltest_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 135,
    "label": "absltest_test.runfiles",
    "parentId": 2
  }, {
    "id": 134,
    "label": "MANIFEST",
    "parentId": 135
  }, {
    "id": 136,
    "label": "absltest_test.py",
    "parentId": 12
  }, {
    "id": 137,
    "label": "absl_Stesting_Stests_Sabsltest_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 138,
    "label": "absltest_test.temp",
    "parentId": 2
  }, {
    "id": 139,
    "label": "absltest_test.zip",
    "parentId": 2
  }, {
    "id": 141,
    "label": "absltest_test",
    "parentId": 94
  }, {
    "id": 140,
    "label": "test.log",
    "parentId": 141
  }, {
    "id": 142,
    "label": "test.cache_status",
    "parentId": 141
  }, {
    "id": 145,
    "label": "logging",
    "parentId": 4
  }, {
    "id": 144,
    "label": "tests",
    "parentId": 145
  }, {
    "id": 143,
    "label": "log_before_import_test",
    "parentId": 144
  }, {
    "id": 146,
    "label": "log_before_import_test.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 148,
    "label": "log_before_import_test.runfiles",
    "parentId": 144
  }, {
    "id": 147,
    "label": "MANIFEST",
    "parentId": 148
  }, {
    "id": 150,
    "label": "tests",
    "parentId": 28
  }, {
    "id": 149,
    "label": "log_before_import_test.py",
    "parentId": 150
  }, {
    "id": 151,
    "label": "absl_Slogging_Stests_Slog_Ubefore_Uimport_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 152,
    "label": "log_before_import_test.temp",
    "parentId": 144
  }, {
    "id": 153,
    "label": "log_before_import_test.zip",
    "parentId": 144
  }, {
    "id": 157,
    "label": "logging",
    "parentId": 67
  }, {
    "id": 156,
    "label": "tests",
    "parentId": 157
  }, {
    "id": 155,
    "label": "log_before_import_test",
    "parentId": 156
  }, {
    "id": 154,
    "label": "test.log",
    "parentId": 155
  }, {
    "id": 158,
    "label": "test.cache_status",
    "parentId": 155
  }, {
    "id": 159,
    "label": "absltest_filtering_test_helper",
    "parentId": 2
  }, {
    "id": 160,
    "label": "absltest_filtering_test_helper.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 162,
    "label": "absltest_filtering_test_helper.runfiles",
    "parentId": 2
  }, {
    "id": 161,
    "label": "MANIFEST",
    "parentId": 162
  }, {
    "id": 163,
    "label": "absltest_filtering_test_helper.py",
    "parentId": 12
  }, {
    "id": 164,
    "label": "absl_Stesting_Stests_Sabsltest_Ufiltering_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 165,
    "label": "absltest_filtering_test_helper.temp",
    "parentId": 2
  }, {
    "id": 166,
    "label": "absltest_filtering_test_helper.zip",
    "parentId": 2
  }, {
    "id": 167,
    "label": "flags_test",
    "parentId": 50
  }, {
    "id": 168,
    "label": "flags_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 170,
    "label": "flags_test.runfiles",
    "parentId": 50
  }, {
    "id": 169,
    "label": "MANIFEST",
    "parentId": 170
  }, {
    "id": 171,
    "label": "flags_test.py",
    "parentId": 56
  }, {
    "id": 172,
    "label": "module_bar.py",
    "parentId": 56
  }, {
    "id": 173,
    "label": "module_baz.py",
    "parentId": 56
  }, {
    "id": 174,
    "label": "module_foo.py",
    "parentId": 56
  }, {
    "id": 175,
    "label": "absl_Sflags_Stests_Sflags_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 176,
    "label": "flags_test.temp",
    "parentId": 50
  }, {
    "id": 177,
    "label": "flags_test.zip",
    "parentId": 50
  }, {
    "id": 179,
    "label": "flags_test",
    "parentId": 65
  }, {
    "id": 178,
    "label": "test.log",
    "parentId": 179
  }, {
    "id": 180,
    "label": "test.cache_status",
    "parentId": 179
  }, {
    "id": 181,
    "label": "verbosity_flag_test",
    "parentId": 144
  }, {
    "id": 182,
    "label": "verbosity_flag_test.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 184,
    "label": "verbosity_flag_test.runfiles",
    "parentId": 144
  }, {
    "id": 183,
    "label": "MANIFEST",
    "parentId": 184
  }, {
    "id": 185,
    "label": "verbosity_flag_test.py",
    "parentId": 150
  }, {
    "id": 186,
    "label": "absl_Slogging_Stests_Sverbosity_Uflag_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 187,
    "label": "verbosity_flag_test.temp",
    "parentId": 144
  }, {
    "id": 188,
    "label": "verbosity_flag_test.zip",
    "parentId": 144
  }, {
    "id": 190,
    "label": "verbosity_flag_test",
    "parentId": 156
  }, {
    "id": 189,
    "label": "test.log",
    "parentId": 190
  }, {
    "id": 191,
    "label": "test.cache_status",
    "parentId": 190
  }, {
    "id": 192,
    "label": "flags_formatting_test",
    "parentId": 50
  }, {
    "id": 193,
    "label": "flags_formatting_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 195,
    "label": "flags_formatting_test.runfiles",
    "parentId": 50
  }, {
    "id": 194,
    "label": "MANIFEST",
    "parentId": 195
  }, {
    "id": 196,
    "label": "flags_formatting_test.py",
    "parentId": 56
  }, {
    "id": 197,
    "label": "absl_Sflags_Stests_Sflags_Uformatting_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 198,
    "label": "flags_formatting_test.temp",
    "parentId": 50
  }, {
    "id": 199,
    "label": "flags_formatting_test.zip",
    "parentId": 50
  }, {
    "id": 201,
    "label": "flags_formatting_test",
    "parentId": 65
  }, {
    "id": 200,
    "label": "test.log",
    "parentId": 201
  }, {
    "id": 202,
    "label": "test.cache_status",
    "parentId": 201
  }, {
    "id": 203,
    "label": "app_test_helper_pure_python",
    "parentId": 98
  }, {
    "id": 204,
    "label": "app_test_helper_pure_python.runfiles_manifest",
    "parentId": 98
  }, {
    "id": 206,
    "label": "app_test_helper_pure_python.runfiles",
    "parentId": 98
  }, {
    "id": 205,
    "label": "MANIFEST",
    "parentId": 206
  }, {
    "id": 207,
    "label": "app_test_helper.py",
    "parentId": 103
  }, {
    "id": 208,
    "label": "absl_Stests_Sapp_Utest_Uhelper_Upure_Upython-runfiles",
    "parentId": 39
  }, {
    "id": 209,
    "label": "app_test_helper_pure_python.temp",
    "parentId": 98
  }, {
    "id": 210,
    "label": "app_test_helper_pure_python.zip",
    "parentId": 98
  }, {
    "id": 211,
    "label": "absltest_fail_fast_test",
    "parentId": 2
  }, {
    "id": 212,
    "label": "absltest_fail_fast_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 214,
    "label": "absltest_fail_fast_test.runfiles",
    "parentId": 2
  }, {
    "id": 213,
    "label": "MANIFEST",
    "parentId": 214
  }, {
    "id": 215,
    "label": "absltest_fail_fast_test.py",
    "parentId": 12
  }, {
    "id": 216,
    "label": "absl_Stesting_Stests_Sabsltest_Ufail_Ufast_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 217,
    "label": "absltest_fail_fast_test.temp",
    "parentId": 2
  }, {
    "id": 218,
    "label": "absltest_fail_fast_test.zip",
    "parentId": 2
  }, {
    "id": 220,
    "label": "absltest_fail_fast_test",
    "parentId": 94
  }, {
    "id": 219,
    "label": "test.log",
    "parentId": 220
  }, {
    "id": 221,
    "label": "test.cache_status",
    "parentId": 220
  }, {
    "id": 222,
    "label": "_helpers_test",
    "parentId": 50
  }, {
    "id": 223,
    "label": "_helpers_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 225,
    "label": "_helpers_test.runfiles",
    "parentId": 50
  }, {
    "id": 224,
    "label": "MANIFEST",
    "parentId": 225
  }, {
    "id": 226,
    "label": "_helpers_test.py",
    "parentId": 56
  }, {
    "id": 227,
    "label": "absl_Sflags_Stests_S_Uhelpers_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 228,
    "label": "_helpers_test.temp",
    "parentId": 50
  }, {
    "id": 229,
    "label": "_helpers_test.zip",
    "parentId": 50
  }, {
    "id": 231,
    "label": "_helpers_test",
    "parentId": 65
  }, {
    "id": 230,
    "label": "test.log",
    "parentId": 231
  }, {
    "id": 232,
    "label": "test.cache_status",
    "parentId": 231
  }, {
    "id": 233,
    "label": "logging_functional_test",
    "parentId": 144
  }, {
    "id": 234,
    "label": "logging_functional_test.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 236,
    "label": "logging_functional_test.runfiles",
    "parentId": 144
  }, {
    "id": 235,
    "label": "MANIFEST",
    "parentId": 236
  }, {
    "id": 237,
    "label": "logging_functional_test.py",
    "parentId": 150
  }, {
    "id": 238,
    "label": "logging_functional_test_helper.py",
    "parentId": 150
  }, {
    "id": 239,
    "label": "logging_functional_test_helper",
    "parentId": 144
  }, {
    "id": 240,
    "label": "absl_Slogging_Stests_Slogging_Ufunctional_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 241,
    "label": "logging_functional_test.temp",
    "parentId": 144
  }, {
    "id": 242,
    "label": "logging_functional_test.zip",
    "parentId": 144
  }, {
    "id": 245,
    "label": "logging_functional_test",
    "parentId": 156
  }, {
    "id": 244,
    "label": "shard_1_of_50",
    "parentId": 245
  }, {
    "id": 243,
    "label": "test.log",
    "parentId": 244
  }, {
    "id": 246,
    "label": "test.cache_status",
    "parentId": 244
  }, {
    "id": 248,
    "label": "shard_2_of_50",
    "parentId": 245
  }, {
    "id": 247,
    "label": "test.log",
    "parentId": 248
  }, {
    "id": 249,
    "label": "test.cache_status",
    "parentId": 248
  }, {
    "id": 251,
    "label": "shard_3_of_50",
    "parentId": 245
  }, {
    "id": 250,
    "label": "test.log",
    "parentId": 251
  }, {
    "id": 252,
    "label": "test.cache_status",
    "parentId": 251
  }, {
    "id": 254,
    "label": "shard_4_of_50",
    "parentId": 245
  }, {
    "id": 253,
    "label": "test.log",
    "parentId": 254
  }, {
    "id": 255,
    "label": "test.cache_status",
    "parentId": 254
  }, {
    "id": 257,
    "label": "shard_5_of_50",
    "parentId": 245
  }, {
    "id": 256,
    "label": "test.log",
    "parentId": 257
  }, {
    "id": 258,
    "label": "test.cache_status",
    "parentId": 257
  }, {
    "id": 260,
    "label": "shard_6_of_50",
    "parentId": 245
  }, {
    "id": 259,
    "label": "test.log",
    "parentId": 260
  }, {
    "id": 261,
    "label": "test.cache_status",
    "parentId": 260
  }, {
    "id": 263,
    "label": "shard_7_of_50",
    "parentId": 245
  }, {
    "id": 262,
    "label": "test.log",
    "parentId": 263
  }, {
    "id": 264,
    "label": "test.cache_status",
    "parentId": 263
  }, {
    "id": 266,
    "label": "shard_8_of_50",
    "parentId": 245
  }, {
    "id": 265,
    "label": "test.log",
    "parentId": 266
  }, {
    "id": 267,
    "label": "test.cache_status",
    "parentId": 266
  }, {
    "id": 269,
    "label": "shard_9_of_50",
    "parentId": 245
  }, {
    "id": 268,
    "label": "test.log",
    "parentId": 269
  }, {
    "id": 270,
    "label": "test.cache_status",
    "parentId": 269
  }, {
    "id": 272,
    "label": "shard_10_of_50",
    "parentId": 245
  }, {
    "id": 271,
    "label": "test.log",
    "parentId": 272
  }, {
    "id": 273,
    "label": "test.cache_status",
    "parentId": 272
  }, {
    "id": 275,
    "label": "shard_11_of_50",
    "parentId": 245
  }, {
    "id": 274,
    "label": "test.log",
    "parentId": 275
  }, {
    "id": 276,
    "label": "test.cache_status",
    "parentId": 275
  }, {
    "id": 278,
    "label": "shard_12_of_50",
    "parentId": 245
  }, {
    "id": 277,
    "label": "test.log",
    "parentId": 278
  }, {
    "id": 279,
    "label": "test.cache_status",
    "parentId": 278
  }, {
    "id": 281,
    "label": "shard_13_of_50",
    "parentId": 245
  }, {
    "id": 280,
    "label": "test.log",
    "parentId": 281
  }, {
    "id": 282,
    "label": "test.cache_status",
    "parentId": 281
  }, {
    "id": 284,
    "label": "shard_14_of_50",
    "parentId": 245
  }, {
    "id": 283,
    "label": "test.log",
    "parentId": 284
  }, {
    "id": 285,
    "label": "test.cache_status",
    "parentId": 284
  }, {
    "id": 287,
    "label": "shard_15_of_50",
    "parentId": 245
  }, {
    "id": 286,
    "label": "test.log",
    "parentId": 287
  }, {
    "id": 288,
    "label": "test.cache_status",
    "parentId": 287
  }, {
    "id": 290,
    "label": "shard_16_of_50",
    "parentId": 245
  }, {
    "id": 289,
    "label": "test.log",
    "parentId": 290
  }, {
    "id": 291,
    "label": "test.cache_status",
    "parentId": 290
  }, {
    "id": 293,
    "label": "shard_17_of_50",
    "parentId": 245
  }, {
    "id": 292,
    "label": "test.log",
    "parentId": 293
  }, {
    "id": 294,
    "label": "test.cache_status",
    "parentId": 293
  }, {
    "id": 296,
    "label": "shard_18_of_50",
    "parentId": 245
  }, {
    "id": 295,
    "label": "test.log",
    "parentId": 296
  }, {
    "id": 297,
    "label": "test.cache_status",
    "parentId": 296
  }, {
    "id": 299,
    "label": "shard_19_of_50",
    "parentId": 245
  }, {
    "id": 298,
    "label": "test.log",
    "parentId": 299
  }, {
    "id": 300,
    "label": "test.cache_status",
    "parentId": 299
  }, {
    "id": 302,
    "label": "shard_20_of_50",
    "parentId": 245
  }, {
    "id": 301,
    "label": "test.log",
    "parentId": 302
  }, {
    "id": 303,
    "label": "test.cache_status",
    "parentId": 302
  }, {
    "id": 305,
    "label": "shard_21_of_50",
    "parentId": 245
  }, {
    "id": 304,
    "label": "test.log",
    "parentId": 305
  }, {
    "id": 306,
    "label": "test.cache_status",
    "parentId": 305
  }, {
    "id": 308,
    "label": "shard_22_of_50",
    "parentId": 245
  }, {
    "id": 307,
    "label": "test.log",
    "parentId": 308
  }, {
    "id": 309,
    "label": "test.cache_status",
    "parentId": 308
  }, {
    "id": 311,
    "label": "shard_23_of_50",
    "parentId": 245
  }, {
    "id": 310,
    "label": "test.log",
    "parentId": 311
  }, {
    "id": 312,
    "label": "test.cache_status",
    "parentId": 311
  }, {
    "id": 314,
    "label": "shard_24_of_50",
    "parentId": 245
  }, {
    "id": 313,
    "label": "test.log",
    "parentId": 314
  }, {
    "id": 315,
    "label": "test.cache_status",
    "parentId": 314
  }, {
    "id": 317,
    "label": "shard_25_of_50",
    "parentId": 245
  }, {
    "id": 316,
    "label": "test.log",
    "parentId": 317
  }, {
    "id": 318,
    "label": "test.cache_status",
    "parentId": 317
  }, {
    "id": 320,
    "label": "shard_26_of_50",
    "parentId": 245
  }, {
    "id": 319,
    "label": "test.log",
    "parentId": 320
  }, {
    "id": 321,
    "label": "test.cache_status",
    "parentId": 320
  }, {
    "id": 323,
    "label": "shard_27_of_50",
    "parentId": 245
  }, {
    "id": 322,
    "label": "test.log",
    "parentId": 323
  }, {
    "id": 324,
    "label": "test.cache_status",
    "parentId": 323
  }, {
    "id": 326,
    "label": "shard_28_of_50",
    "parentId": 245
  }, {
    "id": 325,
    "label": "test.log",
    "parentId": 326
  }, {
    "id": 327,
    "label": "test.cache_status",
    "parentId": 326
  }, {
    "id": 329,
    "label": "shard_29_of_50",
    "parentId": 245
  }, {
    "id": 328,
    "label": "test.log",
    "parentId": 329
  }, {
    "id": 330,
    "label": "test.cache_status",
    "parentId": 329
  }, {
    "id": 332,
    "label": "shard_30_of_50",
    "parentId": 245
  }, {
    "id": 331,
    "label": "test.log",
    "parentId": 332
  }, {
    "id": 333,
    "label": "test.cache_status",
    "parentId": 332
  }, {
    "id": 335,
    "label": "shard_31_of_50",
    "parentId": 245
  }, {
    "id": 334,
    "label": "test.log",
    "parentId": 335
  }, {
    "id": 336,
    "label": "test.cache_status",
    "parentId": 335
  }, {
    "id": 338,
    "label": "shard_32_of_50",
    "parentId": 245
  }, {
    "id": 337,
    "label": "test.log",
    "parentId": 338
  }, {
    "id": 339,
    "label": "test.cache_status",
    "parentId": 338
  }, {
    "id": 341,
    "label": "shard_33_of_50",
    "parentId": 245
  }, {
    "id": 340,
    "label": "test.log",
    "parentId": 341
  }, {
    "id": 342,
    "label": "test.cache_status",
    "parentId": 341
  }, {
    "id": 344,
    "label": "shard_34_of_50",
    "parentId": 245
  }, {
    "id": 343,
    "label": "test.log",
    "parentId": 344
  }, {
    "id": 345,
    "label": "test.cache_status",
    "parentId": 344
  }, {
    "id": 347,
    "label": "shard_35_of_50",
    "parentId": 245
  }, {
    "id": 346,
    "label": "test.log",
    "parentId": 347
  }, {
    "id": 348,
    "label": "test.cache_status",
    "parentId": 347
  }, {
    "id": 350,
    "label": "shard_36_of_50",
    "parentId": 245
  }, {
    "id": 349,
    "label": "test.log",
    "parentId": 350
  }, {
    "id": 351,
    "label": "test.cache_status",
    "parentId": 350
  }, {
    "id": 353,
    "label": "shard_37_of_50",
    "parentId": 245
  }, {
    "id": 352,
    "label": "test.log",
    "parentId": 353
  }, {
    "id": 354,
    "label": "test.cache_status",
    "parentId": 353
  }, {
    "id": 356,
    "label": "shard_38_of_50",
    "parentId": 245
  }, {
    "id": 355,
    "label": "test.log",
    "parentId": 356
  }, {
    "id": 357,
    "label": "test.cache_status",
    "parentId": 356
  }, {
    "id": 359,
    "label": "shard_39_of_50",
    "parentId": 245
  }, {
    "id": 358,
    "label": "test.log",
    "parentId": 359
  }, {
    "id": 360,
    "label": "test.cache_status",
    "parentId": 359
  }, {
    "id": 362,
    "label": "shard_40_of_50",
    "parentId": 245
  }, {
    "id": 361,
    "label": "test.log",
    "parentId": 362
  }, {
    "id": 363,
    "label": "test.cache_status",
    "parentId": 362
  }, {
    "id": 365,
    "label": "shard_41_of_50",
    "parentId": 245
  }, {
    "id": 364,
    "label": "test.log",
    "parentId": 365
  }, {
    "id": 366,
    "label": "test.cache_status",
    "parentId": 365
  }, {
    "id": 368,
    "label": "shard_42_of_50",
    "parentId": 245
  }, {
    "id": 367,
    "label": "test.log",
    "parentId": 368
  }, {
    "id": 369,
    "label": "test.cache_status",
    "parentId": 368
  }, {
    "id": 371,
    "label": "shard_43_of_50",
    "parentId": 245
  }, {
    "id": 370,
    "label": "test.log",
    "parentId": 371
  }, {
    "id": 372,
    "label": "test.cache_status",
    "parentId": 371
  }, {
    "id": 374,
    "label": "shard_44_of_50",
    "parentId": 245
  }, {
    "id": 373,
    "label": "test.log",
    "parentId": 374
  }, {
    "id": 375,
    "label": "test.cache_status",
    "parentId": 374
  }, {
    "id": 377,
    "label": "shard_45_of_50",
    "parentId": 245
  }, {
    "id": 376,
    "label": "test.log",
    "parentId": 377
  }, {
    "id": 378,
    "label": "test.cache_status",
    "parentId": 377
  }, {
    "id": 380,
    "label": "shard_46_of_50",
    "parentId": 245
  }, {
    "id": 379,
    "label": "test.log",
    "parentId": 380
  }, {
    "id": 381,
    "label": "test.cache_status",
    "parentId": 380
  }, {
    "id": 383,
    "label": "shard_47_of_50",
    "parentId": 245
  }, {
    "id": 382,
    "label": "test.log",
    "parentId": 383
  }, {
    "id": 384,
    "label": "test.cache_status",
    "parentId": 383
  }, {
    "id": 386,
    "label": "shard_48_of_50",
    "parentId": 245
  }, {
    "id": 385,
    "label": "test.log",
    "parentId": 386
  }, {
    "id": 387,
    "label": "test.cache_status",
    "parentId": 386
  }, {
    "id": 389,
    "label": "shard_49_of_50",
    "parentId": 245
  }, {
    "id": 388,
    "label": "test.log",
    "parentId": 389
  }, {
    "id": 390,
    "label": "test.cache_status",
    "parentId": 389
  }, {
    "id": 392,
    "label": "shard_50_of_50",
    "parentId": 245
  }, {
    "id": 391,
    "label": "test.log",
    "parentId": 392
  }, {
    "id": 393,
    "label": "test.cache_status",
    "parentId": 392
  }, {
    "id": 394,
    "label": "argparse_flags_test",
    "parentId": 50
  }, {
    "id": 395,
    "label": "argparse_flags_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 397,
    "label": "argparse_flags_test.runfiles",
    "parentId": 50
  }, {
    "id": 396,
    "label": "MANIFEST",
    "parentId": 397
  }, {
    "id": 398,
    "label": "argparse_flags_test.py",
    "parentId": 56
  }, {
    "id": 399,
    "label": "absl_Sflags_Stests_Sargparse_Uflags_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 400,
    "label": "argparse_flags_test.temp",
    "parentId": 50
  }, {
    "id": 401,
    "label": "argparse_flags_test.zip",
    "parentId": 50
  }, {
    "id": 403,
    "label": "argparse_flags_test",
    "parentId": 65
  }, {
    "id": 402,
    "label": "test.log",
    "parentId": 403
  }, {
    "id": 404,
    "label": "test.cache_status",
    "parentId": 403
  }, {
    "id": 405,
    "label": "_argument_parser_test",
    "parentId": 50
  }, {
    "id": 406,
    "label": "_argument_parser_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 408,
    "label": "_argument_parser_test.runfiles",
    "parentId": 50
  }, {
    "id": 407,
    "label": "MANIFEST",
    "parentId": 408
  }, {
    "id": 409,
    "label": "_argument_parser_test.py",
    "parentId": 56
  }, {
    "id": 410,
    "label": "absl_Sflags_Stests_S_Uargument_Uparser_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 411,
    "label": "_argument_parser_test.temp",
    "parentId": 50
  }, {
    "id": 412,
    "label": "_argument_parser_test.zip",
    "parentId": 50
  }, {
    "id": 414,
    "label": "_argument_parser_test",
    "parentId": 65
  }, {
    "id": 413,
    "label": "test.log",
    "parentId": 414
  }, {
    "id": 415,
    "label": "test.cache_status",
    "parentId": 414
  }, {
    "id": 416,
    "label": "_flag_test",
    "parentId": 50
  }, {
    "id": 417,
    "label": "_flag_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 419,
    "label": "_flag_test.runfiles",
    "parentId": 50
  }, {
    "id": 418,
    "label": "MANIFEST",
    "parentId": 419
  }, {
    "id": 420,
    "label": "_flag_test.py",
    "parentId": 56
  }, {
    "id": 421,
    "label": "absl_Sflags_Stests_S_Uflag_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 422,
    "label": "_flag_test.temp",
    "parentId": 50
  }, {
    "id": 423,
    "label": "_flag_test.zip",
    "parentId": 50
  }, {
    "id": 425,
    "label": "_flag_test",
    "parentId": 65
  }, {
    "id": 424,
    "label": "test.log",
    "parentId": 425
  }, {
    "id": 426,
    "label": "test.cache_status",
    "parentId": 425
  }, {
    "id": 427,
    "label": "absltest_sharding_test_helper.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 429,
    "label": "absltest_sharding_test_helper.runfiles",
    "parentId": 2
  }, {
    "id": 428,
    "label": "MANIFEST",
    "parentId": 429
  }, {
    "id": 430,
    "label": "absl_Stesting_Stests_Sabsltest_Usharding_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 431,
    "label": "absltest_sharding_test_helper.temp",
    "parentId": 2
  }, {
    "id": 432,
    "label": "absltest_sharding_test_helper.zip",
    "parentId": 2
  }, {
    "id": 433,
    "label": "_flagvalues_test",
    "parentId": 50
  }, {
    "id": 434,
    "label": "_flagvalues_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 436,
    "label": "_flagvalues_test.runfiles",
    "parentId": 50
  }, {
    "id": 435,
    "label": "MANIFEST",
    "parentId": 436
  }, {
    "id": 437,
    "label": "_flagvalues_test.py",
    "parentId": 56
  }, {
    "id": 438,
    "label": "absl_Sflags_Stests_S_Uflagvalues_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 439,
    "label": "_flagvalues_test.temp",
    "parentId": 50
  }, {
    "id": 440,
    "label": "_flagvalues_test.zip",
    "parentId": 50
  }, {
    "id": 442,
    "label": "_flagvalues_test",
    "parentId": 65
  }, {
    "id": 441,
    "label": "test.log",
    "parentId": 442
  }, {
    "id": 443,
    "label": "test.cache_status",
    "parentId": 442
  }, {
    "id": 444,
    "label": "converter_test",
    "parentId": 144
  }, {
    "id": 445,
    "label": "converter_test.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 447,
    "label": "converter_test.runfiles",
    "parentId": 144
  }, {
    "id": 446,
    "label": "MANIFEST",
    "parentId": 447
  }, {
    "id": 448,
    "label": "converter_test.py",
    "parentId": 150
  }, {
    "id": 449,
    "label": "absl_Slogging_Stests_Sconverter_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 450,
    "label": "converter_test.temp",
    "parentId": 144
  }, {
    "id": 451,
    "label": "converter_test.zip",
    "parentId": 144
  }, {
    "id": 453,
    "label": "converter_test",
    "parentId": 156
  }, {
    "id": 452,
    "label": "test.log",
    "parentId": 453
  }, {
    "id": 454,
    "label": "test.cache_status",
    "parentId": 453
  }, {
    "id": 455,
    "label": "logging_functional_test_helper.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 457,
    "label": "logging_functional_test_helper.runfiles",
    "parentId": 144
  }, {
    "id": 456,
    "label": "MANIFEST",
    "parentId": 457
  }, {
    "id": 458,
    "label": "absl_Slogging_Stests_Slogging_Ufunctional_Utest_Uhelper-runfiles",
    "parentId": 39
  }, {
    "id": 459,
    "label": "logging_functional_test_helper.temp",
    "parentId": 144
  }, {
    "id": 460,
    "label": "logging_functional_test_helper.zip",
    "parentId": 144
  }, {
    "id": 461,
    "label": "xml_reporter_helper_test",
    "parentId": 2
  }, {
    "id": 462,
    "label": "xml_reporter_helper_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 464,
    "label": "xml_reporter_helper_test.runfiles",
    "parentId": 2
  }, {
    "id": 463,
    "label": "MANIFEST",
    "parentId": 464
  }, {
    "id": 465,
    "label": "xml_reporter_helper_test.py",
    "parentId": 12
  }, {
    "id": 466,
    "label": "absl_Stesting_Stests_Sxml_Ureporter_Uhelper_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 467,
    "label": "xml_reporter_helper_test.temp",
    "parentId": 2
  }, {
    "id": 468,
    "label": "xml_reporter_helper_test.zip",
    "parentId": 2
  }, {
    "id": 469,
    "label": "_validators_test",
    "parentId": 50
  }, {
    "id": 470,
    "label": "_validators_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 472,
    "label": "_validators_test.runfiles",
    "parentId": 50
  }, {
    "id": 471,
    "label": "MANIFEST",
    "parentId": 472
  }, {
    "id": 473,
    "label": "_validators_test.py",
    "parentId": 56
  }, {
    "id": 474,
    "label": "absl_Sflags_Stests_S_Uvalidators_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 475,
    "label": "_validators_test.temp",
    "parentId": 50
  }, {
    "id": 476,
    "label": "_validators_test.zip",
    "parentId": 50
  }, {
    "id": 478,
    "label": "_validators_test",
    "parentId": 65
  }, {
    "id": 477,
    "label": "test.log",
    "parentId": 478
  }, {
    "id": 479,
    "label": "test.cache_status",
    "parentId": 478
  }, {
    "id": 480,
    "label": "parameterized_test",
    "parentId": 2
  }, {
    "id": 481,
    "label": "parameterized_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 483,
    "label": "parameterized_test.runfiles",
    "parentId": 2
  }, {
    "id": 482,
    "label": "MANIFEST",
    "parentId": 483
  }, {
    "id": 484,
    "label": "parameterized_test.py",
    "parentId": 12
  }, {
    "id": 485,
    "label": "absl_Stesting_Stests_Sparameterized_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 486,
    "label": "parameterized_test.temp",
    "parentId": 2
  }, {
    "id": 487,
    "label": "parameterized_test.zip",
    "parentId": 2
  }, {
    "id": 489,
    "label": "parameterized_test",
    "parentId": 94
  }, {
    "id": 488,
    "label": "test.log",
    "parentId": 489
  }, {
    "id": 490,
    "label": "test.cache_status",
    "parentId": 489
  }, {
    "id": 491,
    "label": "logging_test",
    "parentId": 144
  }, {
    "id": 492,
    "label": "logging_test.runfiles_manifest",
    "parentId": 144
  }, {
    "id": 494,
    "label": "logging_test.runfiles",
    "parentId": 144
  }, {
    "id": 493,
    "label": "MANIFEST",
    "parentId": 494
  }, {
    "id": 495,
    "label": "logging_test.py",
    "parentId": 150
  }, {
    "id": 496,
    "label": "flagsaver.py",
    "parentId": 13
  }, {
    "id": 497,
    "label": "absl_Slogging_Stests_Slogging_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 498,
    "label": "logging_test.temp",
    "parentId": 144
  }, {
    "id": 499,
    "label": "logging_test.zip",
    "parentId": 144
  }, {
    "id": 501,
    "label": "logging_test",
    "parentId": 156
  }, {
    "id": 500,
    "label": "test.log",
    "parentId": 501
  }, {
    "id": 502,
    "label": "test.cache_status",
    "parentId": 501
  }, {
    "id": 503,
    "label": "flags_helpxml_test",
    "parentId": 50
  }, {
    "id": 504,
    "label": "flags_helpxml_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 506,
    "label": "flags_helpxml_test.runfiles",
    "parentId": 50
  }, {
    "id": 505,
    "label": "MANIFEST",
    "parentId": 506
  }, {
    "id": 507,
    "label": "flags_helpxml_test.py",
    "parentId": 56
  }, {
    "id": 508,
    "label": "absl_Sflags_Stests_Sflags_Uhelpxml_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 509,
    "label": "flags_helpxml_test.temp",
    "parentId": 50
  }, {
    "id": 510,
    "label": "flags_helpxml_test.zip",
    "parentId": 50
  }, {
    "id": 512,
    "label": "flags_helpxml_test",
    "parentId": 65
  }, {
    "id": 511,
    "label": "test.log",
    "parentId": 512
  }, {
    "id": 513,
    "label": "test.cache_status",
    "parentId": 512
  }, {
    "id": 514,
    "label": "absltest_randomization_testcase.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 516,
    "label": "absltest_randomization_testcase.runfiles",
    "parentId": 2
  }, {
    "id": 515,
    "label": "MANIFEST",
    "parentId": 516
  }, {
    "id": 517,
    "label": "absl_Stesting_Stests_Sabsltest_Urandomization_Utestcase-runfiles",
    "parentId": 39
  }, {
    "id": 518,
    "label": "absltest_randomization_testcase.temp",
    "parentId": 2
  }, {
    "id": 519,
    "label": "absltest_randomization_testcase.zip",
    "parentId": 2
  }, {
    "id": 520,
    "label": "flags_numeric_bounds_test",
    "parentId": 50
  }, {
    "id": 521,
    "label": "flags_numeric_bounds_test.runfiles_manifest",
    "parentId": 50
  }, {
    "id": 523,
    "label": "flags_numeric_bounds_test.runfiles",
    "parentId": 50
  }, {
    "id": 522,
    "label": "MANIFEST",
    "parentId": 523
  }, {
    "id": 524,
    "label": "flags_numeric_bounds_test.py",
    "parentId": 56
  }, {
    "id": 525,
    "label": "absl_Sflags_Stests_Sflags_Unumeric_Ubounds_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 526,
    "label": "flags_numeric_bounds_test.temp",
    "parentId": 50
  }, {
    "id": 527,
    "label": "flags_numeric_bounds_test.zip",
    "parentId": 50
  }, {
    "id": 529,
    "label": "flags_numeric_bounds_test",
    "parentId": 65
  }, {
    "id": 528,
    "label": "test.log",
    "parentId": 529
  }, {
    "id": 530,
    "label": "test.cache_status",
    "parentId": 529
  }, {
    "id": 531,
    "label": "xml_reporter_test",
    "parentId": 2
  }, {
    "id": 532,
    "label": "xml_reporter_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 534,
    "label": "xml_reporter_test.runfiles",
    "parentId": 2
  }, {
    "id": 533,
    "label": "MANIFEST",
    "parentId": 534
  }, {
    "id": 535,
    "label": "xml_reporter_test.py",
    "parentId": 12
  }, {
    "id": 536,
    "label": "absl_Stesting_Stests_Sxml_Ureporter_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 537,
    "label": "xml_reporter_test.temp",
    "parentId": 2
  }, {
    "id": 538,
    "label": "xml_reporter_test.zip",
    "parentId": 2
  }, {
    "id": 540,
    "label": "xml_reporter_test",
    "parentId": 94
  }, {
    "id": 539,
    "label": "test.log",
    "parentId": 540
  }, {
    "id": 541,
    "label": "test.cache_status",
    "parentId": 540
  }, {
    "id": 542,
    "label": "app_test",
    "parentId": 98
  }, {
    "id": 543,
    "label": "app_test.runfiles_manifest",
    "parentId": 98
  }, {
    "id": 545,
    "label": "app_test.runfiles",
    "parentId": 98
  }, {
    "id": 544,
    "label": "MANIFEST",
    "parentId": 545
  }, {
    "id": 546,
    "label": "app_test.py",
    "parentId": 103
  }, {
    "id": 547,
    "label": "absl_Stests_Sapp_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 548,
    "label": "app_test.temp",
    "parentId": 98
  }, {
    "id": 549,
    "label": "app_test.zip",
    "parentId": 98
  }, {
    "id": 551,
    "label": "app_test",
    "parentId": 109
  }, {
    "id": 550,
    "label": "test.log",
    "parentId": 551
  }, {
    "id": 552,
    "label": "test.cache_status",
    "parentId": 551
  }, {
    "id": 553,
    "label": "flagsaver_test",
    "parentId": 2
  }, {
    "id": 554,
    "label": "flagsaver_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 556,
    "label": "flagsaver_test.runfiles",
    "parentId": 2
  }, {
    "id": 555,
    "label": "MANIFEST",
    "parentId": 556
  }, {
    "id": 557,
    "label": "flagsaver_test.py",
    "parentId": 12
  }, {
    "id": 558,
    "label": "absl_Stesting_Stests_Sflagsaver_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 559,
    "label": "flagsaver_test.temp",
    "parentId": 2
  }, {
    "id": 560,
    "label": "flagsaver_test.zip",
    "parentId": 2
  }, {
    "id": 562,
    "label": "flagsaver_test",
    "parentId": 94
  }, {
    "id": 561,
    "label": "test.log",
    "parentId": 562
  }, {
    "id": 563,
    "label": "test.cache_status",
    "parentId": 562
  }, {
    "id": 564,
    "label": "absltest_filtering_test",
    "parentId": 2
  }, {
    "id": 565,
    "label": "absltest_filtering_test.runfiles_manifest",
    "parentId": 2
  }, {
    "id": 567,
    "label": "absltest_filtering_test.runfiles",
    "parentId": 2
  }, {
    "id": 566,
    "label": "MANIFEST",
    "parentId": 567
  }, {
    "id": 568,
    "label": "absltest_filtering_test.py",
    "parentId": 12
  }, {
    "id": 569,
    "label": "absl_Stesting_Stests_Sabsltest_Ufiltering_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 570,
    "label": "absltest_filtering_test.temp",
    "parentId": 2
  }, {
    "id": 571,
    "label": "absltest_filtering_test.zip",
    "parentId": 2
  }, {
    "id": 573,
    "label": "absltest_filtering_test",
    "parentId": 94
  }, {
    "id": 572,
    "label": "test.log",
    "parentId": 573
  }, {
    "id": 574,
    "label": "test.cache_status",
    "parentId": 573
  }, {
    "id": 575,
    "label": "command_name_test",
    "parentId": 98
  }, {
    "id": 576,
    "label": "command_name_test.runfiles_manifest",
    "parentId": 98
  }, {
    "id": 578,
    "label": "command_name_test.runfiles",
    "parentId": 98
  }, {
    "id": 577,
    "label": "MANIFEST",
    "parentId": 578
  }, {
    "id": 579,
    "label": "command_name_test.py",
    "parentId": 103
  }, {
    "id": 580,
    "label": "absl_Stests_Scommand_Uname_Utest-runfiles",
    "parentId": 39
  }, {
    "id": 581,
    "label": "command_name_test.temp",
    "parentId": 98
  }, {
    "id": 582,
    "label": "command_name_test.zip",
    "parentId": 98
  }, {
    "id": 584,
    "label": "command_name_test",
    "parentId": 109
  }, {
    "id": 583,
    "label": "test.log",
    "parentId": 584
  }, {
    "id": 585,
    "label": "test.cache_status",
    "parentId": 584
  }, {
    "id": 587,
    "label": "python",
    "parentId": 45
  }, {
    "id": 586,
    "label": "pywrapper_template.txt",
    "parentId": 587
  }, {
    "id": 588,
    "label": "py2wrapper.sh",
    "parentId": 34
  }, {
    "id": 589,
    "label": "py2wrapper_nonstrict.sh",
    "parentId": 34
  }, {
    "id": 590,
    "label": "py3wrapper_nonstrict.sh",
    "parentId": 34
  }]
}
